{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap d3155e1a33b1a2dc46d9","webpack:///./tree-ui.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","MARGIN","CONTAINER","TOP","BOTTOM","NODE","LEFT","NODE_NAME","NODE_METHOD","UPDATE_NAME","TOGGLE_CHILDREN","DELETE_NODE","APPEND_NODE_TEMP","MOVE_NODE","KEY_NUMBER","8","9","13","37","38","40","39","APPEND_DIRECTION","RIGHT","MOVE_DIRECTION","TreeUI","params","this","json","svg","wrapper","addToBottom","addToRight","nodeWidth","nodeHeight","nodeMargin","$svgWrap","d3","select","$svg","$addNodeBottom","$addNodeRight","columnWidth","textLineWidth","textMinLength","rowHeight","init","value","_this2","getJsonData","data","bindEvents","initNodeData","updateUserInputNode","updateNodesLayout","initLayout","initNode","callback","error","_this3","document","addEventListener","e","onKeydownView","on","onClickAddNode","selectedKey","which","isMoveNode","deleteSelectedNode","preventDefault","selectedNodes","getSelectedNodes","direction","selectedNode","appendTempNode","isEditingNode","nodeList","filter","_isEdit","moveSelectNode","nodeObj","hierarchy","children","jsonData","nodes","createNodeData","descendants","map","_isShow","_isDragging","_this4","isInitialLayout","attr","setChildProperties","leaves","node","setLeafLength","setNodeNameProperties","setVerticalIndex","_x","depth","_y","_verticalIndex","columnCount","max","rowCount","svgWidth","svgHeight","transition","duration","updateBackground","parent","margin","currentY","parentY","diffY","childIndex","isShow","getChildren","_childIndex","_isTemp","_childrenLength","_isToggleOpen","len","hasChildren","showChildren","leafLength","_leafLength","nameSize","Util","measureTextSize","_nameWidth","width","_nameHeight","height","strEachLine","splitStringEachLine","_ellipsisName","_isEllpsis","verticalIndex","undefined","brotherNode","Math","_this5","$background","append","blurNode","$rects","selectAll","currentRectCount","needRectCount","ceil","each","$rect","remove","$nodeWrap","$nodeName","nodeData","tooltipMargin","left","top","$tooltip","tooltipHeight","text","clientHeight","tooltipTop","_this6","_this","maxLeafCount","minLeafCount","maximum_leaf_count","minimum_leaf_count","inputNodeData","id","createNodeId","_isUserInput","insertChild","$dragNode","dragNodeData","setPropertyForNode","focusNode","classed","appendDragLayer","$dummyNode","event","x","y","createDummyNode","copySelection","overDragArea","outDragArea","setDragAreaProperties","$dragArea","$target","layoutIndex","parseInt","appendChildren","isLast","getLayerHeight","getLineY","dragAreaHeight","isFirst","_this7","$selectedDragArea","exitFunc","moveNode","toParentId","toChildIndex","toDepth","isMovedNode","updateNode","type","textHtml","forEach","index","str","lineCount","chara","push","$nodes","createNode","updateParentNode","updateLineToChild","updateToggleChildren","parentNode","insertNode","splice","val","propertyName","recursive","_this8","hasLeaf","maxId","dataSet","_this9","enter","setCommonPropetiesForNode","bind","$nodesBg","calculateNodePathD","showTooltip","hideTooltip","editStartNodeName","drag","startDragging","doDragging","endDragging","param","_this10","deleteNode","deleteNodeData","confirm","isSameParent","isYounger","$newNode","exit","newNodeData","selectNodes","selectIds","Array","isArray","$node","isSelected","indexOf","move_direction","newSelectNodes","cousinNodes","selectedData","_this11","_confirm","apply","arguments","toString","doDelete","confirmFunction","isEmpty","trim","newNodeName","focus","$inputNode","blur","someParent","someChildIndex","someDepth","isNodeNameEmpty","editEndNodeName","tempNodeData","isParent","hasToggle","$toggle","circleRadius","toggleChildren","parentData","$container","$text","html","bbox","getBBox","$to","nodeName","attributes","$copy","keys","window"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MARGIN = {\n  CONTAINER: {\n    TOP: 30,\n    BOTTOM: 50\n  },\n  NODE: {\n    LEFT: 10\n  },\n  NODE_NAME: {\n    LEFT: 20\n  }\n};\nvar DEFAULT_DURATION = 500;\n\n// ノード名の１行あたりの最大文字数（半角）\nvar NODE_NAME_LINE_MAX = 26;\n\n// ノード更新時のメソッド識別用\nvar NODE_METHOD = {\n  UPDATE_NAME: 'updateName',\n  TOGGLE_CHILDREN: 'toggleChildren',\n  DELETE_NODE: 'deleteNode',\n  APPEND_NODE_TEMP: 'appendNodeTemp',\n  MOVE_NODE: 'moveNode'\n};\n\nvar KEY_NUMBER = {\n  8: 'DELETE',\n  9: 'TAB',\n  13: 'ENTER',\n  37: 'LEFT',\n  38: 'TOP',\n  40: 'BOTTOM',\n  39: 'RIGHT'\n};\n\n// ノード追加時の位置\nvar APPEND_DIRECTION = {\n  BOTTOM: 'appendToBottom',\n  RIGHT: 'appendToRight'\n};\n\n// ノード移動時の位置\nvar MOVE_DIRECTION = {\n  TOP: 'moveTop',\n  LEFT: 'moveLeft',\n  BOTTOM: 'moveBottom',\n  RIGHT: 'moveRight'\n};\n\nvar TreeUI = function () {\n  function TreeUI(params) {\n    _classCallCheck(this, TreeUI);\n\n    var json = params.json,\n        svg = params.svg,\n        wrapper = params.wrapper,\n        addToBottom = params.addToBottom,\n        addToRight = params.addToRight,\n        nodeWidth = params.nodeWidth,\n        nodeHeight = params.nodeHeight,\n        nodeMargin = params.nodeMargin;\n\n    this.json = json;\n    this.$svgWrap = d3.select(wrapper);\n    this.$svg = d3.select(svg);\n    this.$addNodeBottom = d3.select(addToBottom);\n    this.$addNodeRight = d3.select(addToRight);\n\n    this.columnWidth = nodeWidth || 200;\n    this.textLineWidth = this.columnWidth - 50;\n    this.textMinLength = 10;\n    this.nodeHeight = nodeHeight || 30;\n    this.rowHeight = this.nodeHeight + (nodeMargin || 0);\n    this.init();\n  }\n\n  _createClass(TreeUI, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      this.getJsonData(function (data) {\n        _this2.bindEvents();\n        _this2.initNodeData(data);\n        _this2.updateUserInputNode();\n        _this2.updateNodesLayout();\n        _this2.initLayout();\n        _this2.initNode();\n      });\n    }\n  }, {\n    key: 'getJsonData',\n    value: function getJsonData(callback) {\n      d3.json(this.json, function (error, data) {\n        if (error) throw error;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'bindEvents',\n    value: function bindEvents() {\n      var _this3 = this;\n\n      document.addEventListener('keydown', function (e) {\n        _this3.onKeydownView(e);\n      });\n      this.$addNodeBottom.on('click', function (e) {\n        _this3.onClickAddNode(APPEND_DIRECTION.BOTTOM);\n      });\n      this.$addNodeRight.on('click', function (e) {\n        _this3.onClickAddNode(APPEND_DIRECTION.RIGHT);\n      });\n    }\n  }, {\n    key: 'onKeydownView',\n    value: function onKeydownView(e) {\n      var selectedKey = KEY_NUMBER[e.which];\n      var isMoveNode = selectedKey ? MOVE_DIRECTION[selectedKey] : null;\n\n      if (selectedKey === 'DELETE') {\n        this.deleteSelectedNode();\n      } else if (selectedKey === 'ENTER' || selectedKey === 'TAB') {\n        e.preventDefault();\n        var selectedNodes = this.getSelectedNodes();\n        var direction = selectedKey === 'TAB' ? APPEND_DIRECTION.RIGHT : APPEND_DIRECTION.BOTTOM;\n\n        if (selectedNodes === null || selectedNodes.length === 0) {\n          return;\n        }\n\n        var selectedNode = selectedNodes[0];\n        this.appendTempNode(selectedNode, direction);\n      } else if (isMoveNode) {\n        var isEditingNode = this.nodeList.filter(function (d) {\n          return d._isEdit;\n        }).length > 0;\n\n        if (!isEditingNode) {\n          this.moveSelectNode(MOVE_DIRECTION[selectedKey]);\n          e.preventDefault();\n        }\n      }\n    }\n  }, {\n    key: 'onClickAddNode',\n    value: function onClickAddNode(direction) {\n      var selectedNodes = this.getSelectedNodes();\n      if (selectedNodes === null || selectedNodes.length === 0) {\n        return;\n      }\n\n      var selectedNode = selectedNodes[0];\n      this.appendTempNode(selectedNode, direction);\n    }\n  }, {\n    key: 'createNodeData',\n    value: function createNodeData(nodeObj) {\n      return d3.hierarchy(nodeObj, function (d) {\n        return d.children;\n      });\n    }\n  }, {\n    key: 'initNodeData',\n    value: function initNodeData(jsonData) {\n      this.nodes = this.createNodeData(jsonData);\n      this.nodeList = this.nodes.descendants();\n      this.nodeList = this.nodeList.map(function (d) {\n        d._isShow = true;\n        d._isEdit = false;\n        d._isDragging = false;\n        return d;\n      });\n    }\n  }, {\n    key: 'updateNodesLayout',\n    value: function updateNodesLayout() {\n      var _this4 = this;\n\n      var isInitialLayout = this.$svg.attr('width') === null;\n\n      //各子ノードに対して、親からのインデックス番号を保持する\n      /*\n      node.childIndex = 0\n       |- node.childIndex = 0\n       |- node.childIndex = 1\n       |- node.childIndex = 2\n          |- node.childIndex = 0\n          |- node.childIndex = 1\n      */\n      this.setChildProperties(this.nodes, 0, true);\n\n      // 各親ノードに対して、自分の子孫に存在する葉っぱの数を保持する。子→親の順番で保持する。\n      /*\n      node.leafLength = 3\n       |- node.leafLength = 0 -- leave\n       |- node.leafLength = 0 -- leave\n       |- node.leafLength = 2\n          |- node.leafLength = 0 -- leave\n          |- node.leafLength = 0 -- leave\n      */\n      this.nodes.leaves().map(function (node) {\n        _this4.setLeafLength(node);\n      });\n\n      this.nodeList.map(function (node) {\n        // ノード名が長い場合に３点リーダー表示用プロパティ（ellipsisName）を設定する\n        _this4.setNodeNameProperties(node);\n        //各ノードに対して、縦方向の位置情報（インデックス番号）を割り当てる。親→子の順番で割り当てる。\n        _this4.setVerticalIndex(node);\n      });\n\n      //各ノードのx,y座標を算出\n      this.nodeList.map(function (d) {\n        d._x = d.depth * _this4.columnWidth;\n        d._y = d._verticalIndex * _this4.rowHeight;\n      });\n\n      this.columnCount = d3.max(this.nodeList, function (d) {\n        return d.depth;\n      }) + 1;\n      this.rowCount = d3.max(this.nodeList, function (d) {\n        return d._verticalIndex;\n      }) + 1;\n\n      this.svgWidth = this.columnCount * this.columnWidth;\n      this.svgHeight = this.rowCount * this.rowHeight + MARGIN.CONTAINER.BOTTOM;\n\n      if (isInitialLayout) {\n        this.$svg.attr('width', this.svgWidth).attr('height', this.svgHeight);\n      } else {\n        this.$svg.transition().duration(DEFAULT_DURATION).attr('width', this.svgWidth).attr('height', this.svgHeight);\n      }\n\n      this.updateBackground();\n    }\n  }, {\n    key: 'calculateNodePathD',\n    value: function calculateNodePathD(d) {\n      if (!d || !d.parent) {\n        return;\n      }\n      var margin = MARGIN.NODE.LEFT;\n      var currentY = d._y;\n      var parentY = d.parent._y;\n      var diffY = currentY - parentY;\n      if (diffY === 0) {\n        return 'M0,0 h10';\n      } else {\n        return 'M0,' + -diffY + ' q' + margin / 2 + ',0,' + margin / 2 + ',5 v' + (diffY - 10) + ' q0,' + margin / 2 + ',' + margin / 2 + ',' + margin / 2;\n      }\n    }\n    /*\n    子ノードのレイアウト設定処理。全ての子ノードに対して再帰的に実行する。\n     @param node (Uo) ノード情報\n    @param childIndex (int) 親ノードを基準のした場合のノードの位置インデックス\n    @param isShow (Boolean) ノードを表示する場合はtrue、そうでない場合はfalse\n    */\n\n  }, {\n    key: 'setChildProperties',\n    value: function setChildProperties(node, childIndex, isShow) {\n      var children = this.getChildren(node);\n      node._childIndex = childIndex;\n      node._isShow = isShow;\n      node._isTemp = !!node.data._isTemp;\n\n      if (children && children.length > 0) {\n        node._childrenLength = children.length;\n\n        //親が閉じられている場合は全ての子ノードを非表示にする\n        if (node._isToggleOpen === false) {\n          isShow = false;\n        }\n\n        for (var i = 0, len = children.length; i < len; i++) {\n          this.setChildProperties(children[i], i, isShow);\n        }\n      } else {\n        node._childrenLength = 0;\n      }\n    }\n  }, {\n    key: 'setLeafLength',\n    value: function setLeafLength(node) {\n      if (!this.hasChildren(node)) {\n        node._leafLength = 0;\n      } else {\n        // 表示されているノードのみ葉っぱの個数に含める\n        var showChildren = node.children.filter(function (d) {\n          return d._isShow;\n        });\n        var leafLength = showChildren.length;\n\n        // 子ノードの葉っぱの数を自分の葉っぱの数に加える\n        showChildren.map(function (n) {\n          if (n._leafLength > 0) {\n            leafLength += n._leafLength - 1; //最初の子は親と同じy座標に位置するため-1する\n          }\n        });\n        node._leafLength = leafLength;\n      }\n      if (node.parent !== null) {\n        this.setLeafLength(node.parent);\n      }\n    }\n  }, {\n    key: 'setNodeNameProperties',\n    value: function setNodeNameProperties(node) {\n      //名前用text要素からサイズをキャッシュしておき、他要素のレイアウトの計算に使用する。\n      // let nameSize = this.measureTextSize( this.getLineBreakTexts( node ) );\n      var nameSize = new Util().measureTextSize(node.data.name, this.$svg);\n      node._nameWidth = nameSize.width;\n      node._nameHeight = nameSize.height;\n\n      //項目名が長い（２行以上表示される）場合に省略表示を行う\n      var strEachLine = this.splitStringEachLine(node.data.name);\n      node._ellipsisName = strEachLine[0];\n      node._isEllpsis = strEachLine.length > 1;\n      if (node._isEllpsis) {\n        node._ellipsisName += '...';\n      }\n    }\n  }, {\n    key: 'setVerticalIndex',\n    value: function setVerticalIndex(node) {\n      var verticalIndex = 0;\n\n      if (node.parent === undefined || node.parent === null) {\n        //ルートノードの場合は一番上に表示する\n        verticalIndex = 0;\n      } else if (node._childIndex === 0 || !node._isShow) {\n        //長男ノードの場合は親の隣に位置するため、縦方向の位置は同じ\n        verticalIndex = node.parent._verticalIndex;\n      } else if (node.parent.children !== null) {\n        //兄弟ノードの場合は自分の兄の縦方向の１つ下の位置\n        node.parent.children.map(function (brotherNode) {\n          if (brotherNode._childIndex === node._childIndex - 1) {\n            //兄弟ノードの縦位置と葉っぱノードの数の合計\n            verticalIndex = brotherNode._verticalIndex + Math.max(brotherNode._leafLength - 1, 0) + 1;\n          }\n        });\n      }\n      node._verticalIndex = verticalIndex;\n    }\n  }, {\n    key: 'updateBackground',\n    value: function updateBackground() {\n      var _this5 = this;\n\n      if (this.$background === undefined) {\n        this.$background = this.$svg.append('g').attr('class', 'tree-bg').on('click', function () {\n          _this5.blurNode();\n        });\n      }\n\n      var $rects = this.$background.selectAll('rect');\n      var currentRectCount = $rects.data().length;\n      var needRectCount = Math.ceil(this.svgWidth / this.columnWidth);\n\n      if (currentRectCount < needRectCount) {\n        // 不足分の背景を加える\n        for (var i = currentRectCount; i < needRectCount; i++) {\n          this.$background.append('rect').attr('data-index', i).attr('width', this.columnWidth).attr('height', this.svgHeight).attr('x', i * this.columnWidth).attr('y', 0);\n        }\n      } else if (currentRectCount > needRectCount) {\n        // 余分がある場合は削除する\n        $rects.each(function (d) {\n          var $rect = d3.select(this);\n          var index = $rect.attr('data-index');\n          if (index >= needRectCount) {\n            $rect.remove();\n          }\n        });\n      }\n\n      $rects.transition().duration(DEFAULT_DURATION).attr('width', this.columnWidth).attr('height', this.svgHeight);\n    }\n  }, {\n    key: 'initLayout',\n    value: function initLayout() {\n      this.$nodeWrap = this.$svg.append('g').attr('transform', 'translate(0, ' + MARGIN.CONTAINER.TOP + ')');\n    }\n  }, {\n    key: 'showTooltip',\n    value: function showTooltip($nodeName, nodeData) {\n      if (!nodeData._isEllpsis) {\n        return;\n      }\n\n      var tooltipMargin = {\n        left: 10,\n        top: 5\n      };\n\n      var $tooltip = this.$svgWrap.append('div').attr('class', 'node-tooltip');\n\n      var $tooltipText = $tooltip.append('p').attr('class', 'node-tooltip-text').text(nodeData.data.name);\n\n      var tooltipHeight = $tooltip.node().clientHeight;\n      var tooltipTop = nodeData._y + MARGIN.CONTAINER.TOP - this.rowHeight / 2 - tooltipHeight - tooltipMargin.top;\n\n      $tooltip.attr('style', 'left:' + (nodeData._x + tooltipMargin.left) + 'px; top:' + tooltipTop + 'px;');\n    }\n  }, {\n    key: 'hideTooltip',\n    value: function hideTooltip() {\n      var $tooltip = this.$svgWrap.selectAll('.node-tooltip').remove();\n    }\n  }, {\n    key: 'updateUserInputNode',\n    value: function updateUserInputNode(node) {\n      var _this6 = this;\n\n      var _this = this;\n      var maxLeafCount = void 0;\n      var minLeafCount = void 0;\n\n      this.nodes.each(function (d) {\n        maxLeafCount = d.data.maximum_leaf_count || -1, minLeafCount = d.data.minimum_leaf_count || -1;\n\n        if (maxLeafCount < 0 || minLeafCount < 0) {\n          return true;\n        }\n\n        var inputNodeData = _this.createNodeData({\n          id: _this6.createNodeId(),\n          name: '回答者が入力',\n          children: null\n        });\n        // 回答者入力ノードフラグ\n        inputNodeData._isUserInput = true;\n        _this6.insertChild(d, inputNodeData, 0);\n      });\n\n      this.nodeList = this.nodes.descendants();\n    }\n    // ノードのドラッグ移動開始\n\n  }, {\n    key: 'startDragging',\n    value: function startDragging(target) {\n      this.$dragNode = d3.select(target);\n      var dragNodeData = this.$dragNode.data()[0];\n      this.setPropertyForNode(dragNodeData, '_isDragging', true);\n      this.focusNode(dragNodeData);\n    }\n    // ノードのドラッグ中処理\n\n  }, {\n    key: 'doDragging',\n    value: function doDragging() {\n      var dragNodeData = this.$dragNode.data()[0];\n      if (dragNodeData.depth === 0 || dragNodeData._isUserInput) {\n        return;\n      }\n\n      if (!this.$svgWrap.classed('is-dragging')) {\n        this.appendDragLayer();\n      }\n      if (this.$dummyNode) {\n        this.$dummyNode.attr('transform', 'translate(' + d3.event.x + ', ' + d3.event.y + ')');\n      } else {\n        this.createDummyNode();\n      }\n    }\n  }, {\n    key: 'createDummyNode',\n    value: function createDummyNode() {\n      this.$dummyNode = new Util().copySelection(this.$dragNode, this.$nodeWrap).attr('class', 'node--drag').attr('opacity', '0.5')\n      // dragAreaのmouseoverを検知できるようにdummyNodeのマウスイベントを無効化\n      .attr('pointer-events', 'none');\n\n      this.$dummyNode.attr('data-init-transform', this.$dummyNode.attr('transform'));\n    }\n  }, {\n    key: 'appendDragLayer',\n    value: function appendDragLayer() {\n      var _this = this;\n      var dragNodeData = this.$dragNode.data()[0];\n\n      var overDragArea = function overDragArea(d) {\n        d3.select(this).classed('is-selected', true);\n      };\n      var outDragArea = function outDragArea(d) {\n        d3.select(this).classed('is-selected', false);\n      };\n      var setDragAreaProperties = function setDragAreaProperties($dragArea) {\n        $dragArea.attr('class', 'tree-dragarea').classed('is-disabled', function (d) {\n          // ノードは兄弟ノード間のみ移動できるようにする\n          var $target = d3.select(this);\n          var layoutIndex = parseInt($target.attr('data-childindex'));\n          var isBrothers = d.parent === dragNodeData.parent;\n          var isYoungBrother = isBrothers && dragNodeData._childIndex === layoutIndex - 1;\n          var isSamePosition = isYoungBrother || d._isDragging;\n          // let isDisabled = !isBrothers || isSamePosition || d._isUserInput;\n          var isDisabled = isSamePosition || d._isUserInput;\n\n          return isDisabled;\n        }).attr('width', _this.columnWidth).attr('data-depth', function (d) {\n          return d.depth;\n        }).attr('data-parentid', function (d) {\n          return d.parent ? d.parent.data.id : -1;\n        }).on('mouseover', overDragArea).on('mouseout', outDragArea);\n      };\n      var appendChildren = function appendChildren($dragArea, isLast) {\n        $dragArea.append('rect').attr('width', _this.columnWidth).attr('height', function (d) {\n          return getLayerHeight(d, isLast);\n        });\n        $dragArea.append('line').attr('x1', 0).attr('y1', function (d) {\n          return getLineY(d, isLast);\n        }).attr('x2', $dragArea.attr('width')).attr('y2', function (d) {\n          return getLineY(d, isLast);\n        });\n      };\n      var getLayerHeight = function getLayerHeight(d, isLast) {\n        var dragAreaHeight = 0;\n        var isFirst = d._childIndex === 0;\n        var isTop = d._verticalIndex === 0;\n\n        if (isFirst) {\n          dragAreaHeight = _this.rowHeight / 2;\n          // if( !isTop ) {\n          //   // ノードより上をドラッグ可能領域とする\n          //   dragAreaHeight += _this.svgHeight - ( _this.svgHeight - d._y );\n          // }\n        } else if (isLast) {\n          // ノードより下の領域をドラック可能領域とする\n          dragAreaHeight = _this.svgHeight - d._y - _this.rowHeight / 2;\n        } else {\n          // ノード間をドラッグ可能領域とする\n          var brotherNode = _this.getChildren(d.parent)[d._childIndex - 1];\n          dragAreaHeight = d._y - brotherNode._y;\n        }\n        return dragAreaHeight;\n      };\n      var getLineY = function getLineY(d, isLast) {\n        var isFirst = d._childIndex === 0;\n        var lineY = 0;\n\n        if (isFirst && isLast) {\n          lineY = _this.rowHeight / 2;\n        } else if (isFirst) {\n          // lineY = d._y;\n          lineY = 0;\n        } else if (isLast) {\n          lineY = _this.rowHeight / 2;\n        } else {\n          lineY = getLayerHeight(d, isLast) - _this.rowHeight / 2;\n        }\n        return lineY;\n      };\n\n      var $dragArea = this.$nodeWrap.selectAll('.node').append('g').classed('is-first', function (d) {\n        return d._childIndex === 0;\n      }).attr('transform', function (d) {\n        return 'translate(0, ' + -getLayerHeight(d) + ')';\n      }).attr('data-childindex', function (d) {\n        return d._childIndex;\n      }).call(setDragAreaProperties).call(function ($dragArea) {\n        appendChildren($dragArea, false);\n      });\n\n      var $lastdragArea = this.$nodeWrap.selectAll('.node--youngest').append('g').classed('is-last', true).attr('transform', 'translate(0,0)').attr('data-childindex', function (d) {\n        return d._childIndex + 1;\n      }).call(setDragAreaProperties).call(function ($dragArea) {\n        appendChildren($dragArea, true);\n      });\n\n      $dragArea = this.$nodeWrap.selectAll('.tree-dragarea');\n      this.$svgWrap.classed('is-dragging', true);\n    }\n    // ノードのドラッグ移動終了\n\n  }, {\n    key: 'endDragging',\n    value: function endDragging() {\n      var _this7 = this;\n\n      var $selectedDragArea = d3.select('.tree-dragarea.is-selected');\n      var exitFunc = function exitFunc() {\n        if (!_this7.$dragNode) {\n          return;\n        }\n        var dragNodeData = _this7.$dragNode.data()[0];\n\n        _this7.$nodeWrap.selectAll('.tree-dragarea').remove();\n        _this7.$svgWrap.classed('is-dragging', false);\n        _this7.setPropertyForNode(dragNodeData, '_isDragging', false);\n\n        _this7.$dummyNode = null;\n        _this7.$svg.selectAll('.node--drag').remove();\n        _this7.$dragNode = null;\n      };\n\n      if (this.$dummyNode === undefined || this.$dummyNode === null) {\n        exitFunc();\n        return;\n      }\n\n      if ($selectedDragArea.data().length > 0) {\n        var moveNode = this.$dragNode.data()[0];\n        var toParentId = parseInt($selectedDragArea.attr('data-parentid'));\n        var toChildIndex = parseInt($selectedDragArea.attr('data-childindex'));\n        var toDepth = parseInt($selectedDragArea.attr('data-depth'));\n        var isMovedNode = this.isMovedNode(moveNode, toParentId, toChildIndex, toDepth);\n\n        if (isMovedNode) {\n          // ノードの移動を実行して処理を終了する\n          this.updateNode({\n            type: NODE_METHOD.MOVE_NODE,\n            data: {\n              moveNode: this.$dragNode.data()[0],\n              toParentId: toParentId,\n              toChildIndex: toChildIndex,\n              toDepth: toDepth\n            }\n          });\n          exitFunc();\n          return;\n        }\n      }\n      // 移動しない場合はダミーノードを元の位置に戻し、削除する\n      this.$dummyNode.transition().duration(DEFAULT_DURATION).attr('transform', this.$dummyNode.attr('data-init-transform')).on('end', function () {\n        exitFunc();\n      });\n    }\n    // 項目名の改行を行なった結果をHTML要素に変換して返す\n\n  }, {\n    key: 'getLineBreakTexts',\n    value: function getLineBreakTexts(node) {\n      var lineHeight = 1.5;\n      var textHtml = '';\n      var strEachLine = this.splitStringEachLine(node.data.name);\n\n      strEachLine.forEach(function (text, index) {\n        textHtml += '<tspan class=\"line line' + index + '\" x=\"0\" y=\"' + index * lineHeight + 'em\" dx=\"0.6em\" dy=\"0.35em\">' + text + '</tspan>';\n      });\n      return textHtml;\n    }\n    // ノード名複数行対応：行ごとの文字列に分割した配列を作成する\n\n  }, {\n    key: 'splitStringEachLine',\n    value: function splitStringEachLine(str) {\n      var strEachLine = [];\n      var lineCount = 0;\n      var strLength = void 0;\n\n      for (var i = 0, len = str.length; i < len; i++) {\n        var chara = str[i];\n        if (strEachLine.length <= lineCount) {\n          strEachLine.push('');\n        }\n        strEachLine[lineCount] += chara;\n\n        // 1行内の文字数が一定数より多い場合は改行の可能性がある（一定数＝全角文字で１行に必ず入る文字数）\n        var isPossibilityLineBreak = strEachLine[lineCount].length > this.textMinLength;\n        if (isPossibilityLineBreak) {\n          // 文字幅が１行に表示できる文字を超えている場合は改行\n          var strSize = new Util().measureTextSize(strEachLine[lineCount], this.$svg);\n          if (strSize.width >= this.textLineWidth) {\n            ++lineCount;\n          }\n        }\n      }\n      return strEachLine;\n    }\n  }, {\n    key: 'initNode',\n    value: function initNode() {\n      this.$nodes = this.createNode(this.nodeList);\n      this.updateParentNode();\n    }\n  }, {\n    key: 'updateParentNode',\n    value: function updateParentNode() {\n      this.updateLineToChild();\n      this.updateToggleChildren();\n    }\n    // 親ノードが子を持っているか確認する\n\n  }, {\n    key: 'hasChildren',\n    value: function hasChildren(node) {\n      var children = this.getChildren(node);\n      return children && children.length > 0;\n    }\n    // 親ノードの子を取得する\n\n  }, {\n    key: 'getChildren',\n    value: function getChildren(node) {\n      return node.children;\n    }\n    // 親ノードの子に指定されたノードを挿入する\n\n  }, {\n    key: 'insertChild',\n    value: function insertChild(parentNode, insertNode, childIndex) {\n\n      if (this.hasChildren(parentNode)) {\n        var children = this.getChildren(parentNode);\n\n        if (childIndex === undefined || children.length <= childIndex) {\n          children.push(insertNode);\n          parentNode.data.children.push(insertNode.data);\n        } else {\n          children.splice(childIndex, 0, insertNode);\n          parentNode.data.children.splice(childIndex, 0, insertNode.data);\n        }\n      } else {\n        parentNode.children = [insertNode];\n        parentNode.data.children = [insertNode];\n      }\n      insertNode.parent = parentNode;\n      this.setPropertyForNode(insertNode, 'depth', parentNode.depth + 1, function (val) {\n        return val + 1;\n      });\n    }\n    /*\n    ノードの子孫も含めて任意のプロパティを更新する\n    @param node (Object) 更新の対象となるノードデータ\n    @param propertyName (String) プロパティ名\n    @param value (anything) 値\n    @param recursive (function) 子孫へ再起的に実行する際にvalueに対して何かしら処理を行う際に使用する\n    */\n\n  }, {\n    key: 'setPropertyForNode',\n    value: function setPropertyForNode(node, propertyName, value, recursive) {\n      node[propertyName] = value;\n\n      if (!this.hasChildren(node)) {\n        return;\n      }\n      var children = this.getChildren(node);\n\n      if (typeof recursive === 'function') {\n        value = recursive(value);\n      }\n\n      for (var i = 0, len = children.length; i < len; i++) {\n        this.setPropertyForNode(children[i], propertyName, value, recursive);\n      }\n    }\n    /*\n    ノード作成・更新時に共通のプロパティを設定する処理\n    */\n\n  }, {\n    key: 'setCommonPropetiesForNode',\n    value: function setCommonPropetiesForNode($nodes) {\n      var _this8 = this;\n\n      $nodes.classed('node--oldest', function (d) {\n        return d._childIndex === 0;\n      }).classed('node--youngest', function (d) {\n        return d.parent && d._childIndex === _this8.getChildren(d.parent).length - 1;\n      }).classed('node--branch', function (d) {\n        var children = [];\n        // let leafs = [];\n\n        if (_this8.hasChildren(d)) {\n          children = _this8.getChildren(d);\n          // leafs = children.filter((d) => {\n          //   return !this.hasChildren(d);\n          // });\n        }\n        return children.length > 0;\n      }).classed('node--leaf', function (d) {\n        return !_this8.hasChildren(d);\n      }).classed('node--other', function (d) {\n        // 子は存在するが、葉を１つも持っていないノード\n        var hasChildren = _this8.getChildren(d);\n        var hasLeaf = false;\n        if (_this8.hasChildren(d)) {\n          _this8.getChildren(d).map(function (d) {\n            if (!_this8.hasChildren(d)) {\n              hasLeaf = true;\n              return false;\n            }\n          });\n        }\n        return hasChildren && !hasLeaf;\n      }).classed('node--userinput', function (d) {\n        return d._isUserInput;\n      }).classed('is-close', false);\n    }\n    // ノードを追加する際に新しいIDを作成する\n\n  }, {\n    key: 'createNodeId',\n    value: function createNodeId() {\n      var maxId = d3.max(this.nodes.descendants(), function (d) {\n        return d.data.id;\n      });\n      return ++maxId;\n    }\n    // ノード作成処理\n\n  }, {\n    key: 'createNode',\n    value: function createNode(dataSet) {\n      var _this9 = this;\n\n      var _this = this;\n\n      var $nodes = this.$nodeWrap.selectAll('.node').data(dataSet, function (d) {\n        return d.data.id;\n      }).enter().append('g').attr('class', function (d) {\n        return 'node';\n      }).call(this.setCommonPropetiesForNode.bind(this)).attr('width', this.columnWidth).attr('height', this.nodeHeight).attr('opacity', 1).attr('transform', function (d) {\n        return 'translate(' + d._x + ', ' + d._y + ')';\n      });\n\n      //背景に敷くためのrect要素を先に要素追加しておき、後でプロパティを設定する\n      var $nodesBg = $nodes.append('rect');\n\n      //ノード名の左側に表示するアイコン\n      // let $nodeHead = $nodes.append('circle')\n      //   .attr('r', 3);\n\n      //ノード名用text要素\n      var $nodeText = $nodes.append('text').attr('class', 'node-name').attr('x', MARGIN.NODE_NAME.LEFT).attr('y', '0.35em').text(function (d) {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n      // 親ノードと子ノードを繋ぐためのパス\n      var $nodePath = $nodes.append('path').attr('class', 'node-path').attr('d', this.calculateNodePathD).attr('fill', 'none');\n\n      //背景用rect要素のプロパティを設定\n      //ノードドラッグ時に発生させたくないイベントはこのSelectionにバインドする\n      $nodesBg.attr('height', function (d) {\n        return d._nameHeight;\n      }).attr('class', 'node-bg').attr('width', this.columnWidth - MARGIN.NODE.LEFT).attr('height', this.nodeHeight).attr('x', MARGIN.NODE.LEFT).attr('y', -(this.nodeHeight / 2)).attr('fill', 'transparent').on('mouseover', function (d) {\n        if (_this.$svgWrap.classed('is-dragging')) {\n          return;\n        }\n        _this.showTooltip(d3.select(this), d);\n      }).on('mouseout', function (d) {\n        _this9.hideTooltip();\n      }).on('click', function (d) {\n        _this.focusNode(d);\n      }).on('dblclick', function (d) {\n        _this.editStartNodeName(d);\n      });\n\n      $nodes.each(function (d) {\n        if (!d._isUserInput) {\n          //回答者入力欄以外はドラッグ＆ドロップで移動可能にする\n          d3.select(this).call(d3.drag().on('start', function () {\n            _this.startDragging(this);\n          }).on('drag', function () {\n            _this.doDragging();\n          }).on('end', function () {\n            _this.endDragging();\n          }));\n        } else {\n          //回答者入力ノード用ラベル\n          d3.select(this).append('text').attr('class', 'node--userinput-range').attr('x', _this.columnWidth - 10).attr('y', '0.35em').attr('text-anchor', 'end').text(function (d) {\n            var maxLeafCount = d.parent.data.maximum_leaf_count;\n            var minLeafCount = d.parent.data.minimum_leaf_count;\n            return minLeafCount + '\\u301C' + maxLeafCount;\n          });\n        };\n      });\n\n      return $nodes;\n    }\n    // ノード更新処理\n\n  }, {\n    key: 'updateNode',\n    value: function updateNode(param) {\n      var _this10 = this;\n\n      var _this = this;\n\n      if (param) {\n        switch (param.type) {\n          case NODE_METHOD.UPDATE_NAME:\n            // 指定されたパラメータを元に内部データを更新する\n            this.nodeList.map(function (node) {\n              if (param.data.id !== node.data.id) return true;\n              for (var key in param.data) {\n                node.data[key] = param.data[key];\n              }\n              _this10.setNodeNameProperties(node);\n            });\n            break;\n          case NODE_METHOD.TOGGLE_CHILDREN:\n            var node = param.data.node;\n            if (node._isToggleOpen === undefined) {\n              node._isToggleOpen = false;\n            } else {\n              node._isToggleOpen = !node._isToggleOpen;\n            }\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.DELETE_NODE:\n            //ルートノードは削除できない\n            if (param.data.deleteNode.depth === 0) {\n              return;\n            }\n\n            // 対象ノードをデータから削除し、各ノードの位置を再計算する。\n            this.deleteNodeData(param.data.deleteNode, param.confirm);\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.APPEND_NODE_TEMP:\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.MOVE_NODE:\n            var data = param.data;\n            var moveNode = data.moveNode,\n                toParentId = data.toParentId,\n                toChildIndex = data.toChildIndex,\n                toDepth = data.toDepth;\n\n            var isSameParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n            var isYounger = moveNode._childIndex < toChildIndex;\n\n            if (isSameParent && isYounger) {\n              --toChildIndex;\n            }\n\n            if (!this.isMovedNode(moveNode, toParentId, toChildIndex, toDepth)) {\n              return;\n            }\n\n            //ノードリストから対象のノードを取り除く\n            this.deleteNodeData(moveNode);\n\n            //対象ノードを移動先の位置に加える\n            this.nodes.each(function (d) {\n              if (d.data.id !== toParentId) {\n                return true;\n              }\n              _this10.insertChild(d, moveNode, toChildIndex);\n              return false;\n            });\n\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n        }\n      }\n\n      var $newNode = this.createNode(this.nodeList);\n\n      // 内部データを元に各ノードの状態を更新する\n      this.$nodes = this.$nodeWrap.selectAll('.node').data(this.nodeList, function (d) {\n        // idをもとに変更前と変更後のノード情報を紐づける\n        return d.data.id;\n      }).call(this.setCommonPropetiesForNode.bind(this)).transition().on('end', function (d) {\n        // アニメーションが終わった後にノードを非表示にする\n        if (!d._isShow) {\n          d3.select(this).classed('is-close', true);\n        }\n      }).duration(DEFAULT_DURATION).attr('opacity', function (d) {\n        return d._isShow ? 1 : 0;\n      }).attr('transform', function (d) {\n        return 'translate(' + d._x + ', ' + d._y + ')';\n      });\n\n      var $delNodes = this.$nodeWrap.selectAll('.node').data(this.nodeList, function (d) {\n        return d.data.id;\n      }).exit().remove();\n\n      var $texts = this.$nodes.selectAll('.node-name').text(function (d) {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n      this.$nodeWrap.selectAll('.node-path').transition().duration(DEFAULT_DURATION).attr('d', this.calculateNodePathD);\n\n      if ($newNode !== undefined && $newNode !== null && $newNode.data().length > 0) {\n        //内部データを更新した後、追加されたノードは編集状態にする\n        var newNodeData = $newNode.data()[0];\n        this.editStartNodeName(newNodeData);\n        this.focusNode(newNodeData);\n      }\n\n      this.updateParentNode();\n    }\n  }, {\n    key: 'focusNode',\n    value: function focusNode(selectNodes) {\n      var selectIds = [];\n\n      if (Array.isArray(selectNodes)) {\n        selectNodes.map(function (d) {\n          selectIds.push(d.data.id);\n        });\n      } else {\n        selectIds.push(selectNodes.data.id);\n      }\n\n      this.$nodes.each(function (d) {\n        var $node = d3.select(this);\n        var isSelected = selectIds.indexOf(d.data.id) > -1;\n        $node.classed('is-selected', isSelected);\n      });\n    }\n  }, {\n    key: 'blurNode',\n    value: function blurNode() {\n      this.$nodes.each(function (d) {\n        d3.select(this).classed('is-selected', false);\n      });\n    }\n  }, {\n    key: 'moveSelectNode',\n    value: function moveSelectNode(move_direction) {\n      var selectedNodes = this.getSelectedNodes();\n      if (selectedNodes === null || selectedNodes.length === 0) {\n        return;\n      }\n      var selectedNode = selectedNodes[0];\n      var _childIndex = selectedNode._childIndex,\n          depth = selectedNode.depth;\n\n      var newSelectNodes = void 0;\n      var cousinNodes = void 0;\n\n      switch (move_direction) {\n        case MOVE_DIRECTION.TOP:\n          cousinNodes = this.nodeList.filter(function (d) {\n            return selectedNode.depth === d.depth && selectedNode._verticalIndex > d._verticalIndex;\n          });\n          newSelectNodes = cousinNodes.length > 0 ? cousinNodes[cousinNodes.length - 1] : undefined;\n          break;\n        case MOVE_DIRECTION.LEFT:\n          newSelectNodes = selectedNode.parent ? [selectedNode.parent] : undefined;\n          break;\n        case MOVE_DIRECTION.BOTTOM:\n          cousinNodes = this.nodeList.filter(function (d) {\n            return selectedNode.depth === d.depth && selectedNode._verticalIndex < d._verticalIndex;\n          });\n          newSelectNodes = cousinNodes.length > 0 ? cousinNodes[0] : undefined;\n          break;\n        case MOVE_DIRECTION.RIGHT:\n          newSelectNodes = this.nodeList.filter(function (d) {\n            return selectedNode === d.parent && d._childIndex === 0 && d.depth === depth + 1;\n          });\n          break;\n      }\n\n      if (newSelectNodes === undefined || newSelectNodes.length === 0) {\n        return;\n      }\n\n      this.focusNode(newSelectNodes);\n    }\n  }, {\n    key: 'getSelectedNodes',\n    value: function getSelectedNodes() {\n      var selectedNodes = this.$nodeWrap.select('.node.is-selected').data();\n      if (selectedNodes === undefined && selectedData.length === 0) {\n        return null;\n      }\n      return selectedNodes;\n    }\n  }, {\n    key: 'deleteSelectedNode',\n    value: function deleteSelectedNode() {\n      var selectedNodes = this.getSelectedNodes();\n\n      for (var i = 0, len = selectedNodes.length; i < len; i++) {\n        this.deleteNode(selectedNodes[i]);\n      }\n    }\n    // ツリーに表示されているノードを削除する\n\n  }, {\n    key: 'deleteNode',\n    value: function deleteNode(node) {\n      var _this11 = this;\n\n      //編集中には削除処理を実行しない\n      if (node._isEdit) {\n        return;\n      }\n\n      this.updateNode({\n        type: NODE_METHOD.DELETE_NODE,\n        data: {\n          deleteNode: node\n        },\n        confirm: function (_confirm) {\n          function confirm(_x) {\n            return _confirm.apply(this, arguments);\n          }\n\n          confirm.toString = function () {\n            return _confirm.toString();\n          };\n\n          return confirm;\n        }(function (deleteNode) {\n          // 確認処理を行い、キャンセルした場合は処理を中断する。\n          var hasChildren = _this11.getChildren(deleteNode) && _this11.getChildren(deleteNode).length > 0;\n          var doDelete = true;\n\n          if (hasChildren) {\n            doDelete = confirm('子階層のノードも削除されますが、本当に削除してもよろしいですか？');\n          }\n          return doDelete;\n        })\n      });\n    }\n    // 内部ノード情報から対象のノードを削除する\n\n  }, {\n    key: 'deleteNodeData',\n    value: function deleteNodeData(node, confirmFunction) {\n      var deleteNode = null;\n      var parentNode = null;\n\n      this.nodes.each(function (d) {\n        if (node === d) {\n          deleteNode = d;\n          parentNode = d.parent;\n          return false;\n        }\n      });\n\n      // 確認処理を行い、キャンセルした場合は処理を中断する。\n      var doConfirm = confirmFunction && typeof confirmFunction === 'function';\n      if (doConfirm && !confirmFunction(deleteNode)) {\n        return;\n      }\n\n      parentNode.children.map(function (d, i) {\n        if (d !== deleteNode) {\n          return true;\n        }\n        parentNode.children.splice(i, 1);\n      });\n    }\n  }, {\n    key: 'editStartNodeName',\n    value: function editStartNodeName(node) {\n      var _this = this;\n      var $node = void 0;\n\n      if (node._isUserInput) {\n        return;\n      }\n\n      this.$nodes.each(function (d) {\n        if (d.data.id === node.data.id) {\n          $node = d3.select(this);\n          return false;\n        }\n      });\n\n      node._isEdit = true;\n      $node.classed('is-editing', true);\n\n      //テキストボックスを生成し、編集状態にする\n      var $inputNode = this.$svgWrap.append('input').attr('type', 'text').attr('value', node.data.name).attr('class', 'node-textbox').attr('style', 'left:' + (node._x + MARGIN.NODE.LEFT) + 'px; top:' + (node._y + MARGIN.CONTAINER.TOP - this.nodeHeight / 2) + 'px; width:' + (this.columnWidth - MARGIN.NODE.LEFT) + 'px; height:' + this.nodeHeight + 'px;').on('blur', function () {\n        var isEmpty = this.value.trim() === '';\n        var newNodeName = d3.select(this).node().value;\n\n        //テキストボックスからフォーカスが外れた場合は元のラベルを更新する\n        node._isEdit = false;\n        $node.classed('is-editing', false);\n        _this.$svgWrap.selectAll('.node-textbox').remove();\n\n        if (isEmpty) {\n          if (node._isTemp) {\n            //ノード追加時の場合は追加前の状態に戻す\n            _this.deleteNode(node);\n            return;\n          } else {\n            //空文字の場合は元の名前に戻す\n            newNodeName = node.data.name;\n          }\n        }\n\n        _this.updateNode({\n          type: NODE_METHOD.UPDATE_NAME,\n          data: {\n            id: node.data.id,\n            name: newNodeName\n          }\n        });\n      });\n\n      $inputNode.node().focus();\n    }\n  }, {\n    key: 'editEndNodeName',\n    value: function editEndNodeName() {\n      var $inputNode = this.$svgWrap.selectAll('.node-textbox');\n      if ($inputNode.data().length === 0) {\n        return;\n      }\n      $inputNode.node().blur();\n\n      this.updateLineToChild();\n    }\n  }, {\n    key: 'isMovedNode',\n    value: function isMovedNode(moveNode, toParentId, toChildIndex, toDepth) {\n      var someParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n      var someChildIndex = moveNode._childIndex === toChildIndex;\n      var someDepth = moveNode.depth === toDepth;\n      return !(someParent && someChildIndex && someDepth);\n    }\n  }, {\n    key: 'isNodeNameEmpty',\n    value: function isNodeNameEmpty() {\n      var isEmpty = true;\n      var $inputNode = this.$svgWrap.selectAll('.node-textbox');\n      if ($inputNode.data().length === 0) {\n        return isEmpty;\n      }\n      isEmpty = $inputNode.node().value.trim() === '';\n      return isEmpty;\n    }\n  }, {\n    key: 'appendTempNode',\n    value: function appendTempNode(selectedNode, direction) {\n\n      if (selectedNode._isEdit) {\n        if (!this.isNodeNameEmpty()) {\n          this.editEndNodeName();\n        }\n        return;\n      } else if (selectedNode._isUserInput && direction === APPEND_DIRECTION.RIGHT) {\n        return;\n      }\n\n      var parentNode = selectedNode.parent;\n      if (parentNode === null && direction === APPEND_DIRECTION.BOTTOM) {\n        //ルート階層の下にノードは追加できないようにする\n        return;\n      }\n\n      // ノード追加を行うための一時ノードを生成してツリーに加える\n      var tempNodeData = this.createNodeData({\n        id: this.createNodeId(),\n        name: '',\n        children: null,\n        _isTemp: true\n      });\n\n      switch (direction) {\n        case APPEND_DIRECTION.RIGHT:\n          this.insertChild(selectedNode, tempNodeData);\n          break;\n        case APPEND_DIRECTION.BOTTOM:\n          this.insertChild(parentNode, tempNodeData, selectedNode._childIndex + 1);\n          break;\n      }\n\n      this.updateNode({\n        type: NODE_METHOD.APPEND_NODE_TEMP\n      });\n    }\n  }, {\n    key: 'updateToggleChildren',\n    value: function updateToggleChildren() {\n      var _this = this;\n      var circleRadius = 8;\n\n      this.$nodes.each(function (d) {\n        var $node = d3.select(this);\n        var isParent = _this.hasChildren(d);\n        var hasToggle = $node.select('.node-toggle').node() !== null;\n\n        if (isParent && !hasToggle) {\n          var $toggle = $node.append('g').attr('class', 'node-toggle').attr('transform', 'translate(' + (_this.columnWidth - circleRadius * 2) + ', 0)').on('click', function (d) {\n            _this.toggleChildren(d);\n          });\n\n          var $circles = $toggle.append('circle').attr('r', circleRadius);\n\n          var $texts = $toggle.append('text').attr('class', 'node-toggle-label').attr('width', circleRadius * 2).attr('hegith', circleRadius * 2).attr('text-anchor', 'middle').attr('dy', circleRadius / 2).text(d._isToggleOpen === false ? '+' : '–');\n        } else if (isParent && hasToggle) {\n          $node.select('.node-toggle-label').text(d._isToggleOpen === false ? '+' : '–');\n        } else if (!isParent && hasToggle) {\n          $node.select('.node-toggle').remove();\n        }\n      });\n    }\n  }, {\n    key: 'updateLineToChild',\n    value: function updateLineToChild() {\n      var _this = this;\n\n      this.$svgWrap.selectAll('.node-branch-line').remove();\n      this.$svgWrap.selectAll('.node--other').each(function (d) {\n        var $node = d3.select(this);\n        var isParent = _this.hasChildren(d);\n        var hasLine = $node.select('.node-branch-line').node() !== null;\n\n        // if( isParent && !hasLine && !d._isEllpsis ) {\n        //   $node.append('line')\n        //     .attr('class', 'node-branch-line')\n        //     .attr('stroke', 'black')\n        //     .attr('stroke-width', 1)\n        //     .attr('stroke-dasharray', '1 4')\n        //     .attr('x1', d._nameWidth + MARGIN.NODE_NAME.LEFT + 10)\n        //     .attr('y1', 0)\n        //     .attr('x2', _this.columnWidth - 10)\n        //     .attr('y2', 0);\n        // }\n      });\n    }\n  }, {\n    key: 'toggleChildren',\n    value: function toggleChildren(parentData) {\n      this.updateNode({\n        type: NODE_METHOD.TOGGLE_CHILDREN,\n        data: {\n          node: parentData\n        }\n      });\n    }\n  }]);\n\n  return TreeUI;\n}();\n\nvar Util = function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, [{\n    key: 'measureTextSize',\n    value: function measureTextSize(str, $container) {\n      var $text = $container.append('text').attr('class', 'temp-measure-text').html(str);\n      var bbox = $text.node().getBBox();\n      $text.remove();\n      return bbox;\n    }\n  }, {\n    key: 'copySelection',\n    value: function copySelection($target, $to) {\n      var node = $target.node();\n      var nodeName = node.nodeName,\n          attributes = node.attributes,\n          children = node.children;\n\n      var $copy = $to.append(nodeName);\n\n      Object.keys(attributes).forEach(function (key) {\n        $copy.attr(attributes[key].name, attributes[key].value);\n      });\n      $copy.html($target.html());\n\n      return $copy;\n    }\n  }]);\n\n  return Util;\n}();\n\n(function () {\n  window.TreeUI = TreeUI;\n})();\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d3155e1a33b1a2dc46d9","const MARGIN = {\n  CONTAINER: {\n    TOP: 30,\n    BOTTOM: 50\n  },\n  NODE: {\n    LEFT: 10\n  },\n  NODE_NAME: {\n    LEFT: 20\n  }\n};\nconst DEFAULT_DURATION = 500;\n\n// ノード名の１行あたりの最大文字数（半角）\nconst NODE_NAME_LINE_MAX = 26;\n\n// ノード更新時のメソッド識別用\nconst NODE_METHOD = {\n  UPDATE_NAME: 'updateName',\n  TOGGLE_CHILDREN: 'toggleChildren',\n  DELETE_NODE: 'deleteNode',\n  APPEND_NODE_TEMP: 'appendNodeTemp',\n  MOVE_NODE: 'moveNode'\n};\n\nconst KEY_NUMBER = {\n  8: 'DELETE',\n  9: 'TAB',\n  13: 'ENTER',\n  37: 'LEFT',\n  38: 'TOP',\n  40: 'BOTTOM',\n  39: 'RIGHT'\n};\n\n// ノード追加時の位置\nconst APPEND_DIRECTION = {\n  BOTTOM: 'appendToBottom',\n  RIGHT: 'appendToRight'\n};\n\n// ノード移動時の位置\nconst MOVE_DIRECTION = {\n  TOP: 'moveTop',\n  LEFT: 'moveLeft',\n  BOTTOM: 'moveBottom',\n  RIGHT: 'moveRight'\n};\n\nclass TreeUI {\n  constructor(params) {\n    const {\n      json,\n      svg,\n      wrapper,\n      addToBottom,\n      addToRight,\n      nodeWidth,\n      nodeHeight,\n      nodeMargin\n    } = params\n    this.json = json;\n    this.$svgWrap = d3.select(wrapper);\n    this.$svg = d3.select(svg);\n    this.$addNodeBottom = d3.select(addToBottom);\n    this.$addNodeRight = d3.select(addToRight);\n\n    this.columnWidth = nodeWidth || 200;\n    this.textLineWidth = this.columnWidth - 50;\n    this.textMinLength = 10;\n    this.nodeHeight = nodeHeight || 30;\n    this.rowHeight = this.nodeHeight + (nodeMargin || 0);\n    this.init()\n  }\n  init() {\n    this.getJsonData((data) => {\n      this.bindEvents();\n      this.initNodeData(data);\n      this.updateUserInputNode();\n      this.updateNodesLayout();\n      this.initLayout();\n      this.initNode();\n    });\n  }\n  getJsonData(callback) {\n    d3.json(this.json, (error, data) => {\n      if (error) throw error;\n      callback(data);\n    });\n  }\n  bindEvents() {\n    document.addEventListener('keydown', (e) => {\n      this.onKeydownView(e);\n    });\n    this.$addNodeBottom.on('click', (e) => {\n      this.onClickAddNode( APPEND_DIRECTION.BOTTOM );\n    });\n    this.$addNodeRight.on('click', (e) => {\n      this.onClickAddNode( APPEND_DIRECTION.RIGHT );\n    });\n  }\n  onKeydownView(e) {\n    let selectedKey = KEY_NUMBER[e.which];\n    let isMoveNode = selectedKey ? MOVE_DIRECTION[selectedKey] : null;\n\n    if( selectedKey === 'DELETE' ) {\n      this.deleteSelectedNode();\n    }\n    else if( selectedKey === 'ENTER' || selectedKey === 'TAB' ) {\n      e.preventDefault();\n      let selectedNodes = this.getSelectedNodes();\n      let direction = selectedKey === 'TAB' ? APPEND_DIRECTION.RIGHT : APPEND_DIRECTION.BOTTOM;\n\n      if( selectedNodes === null || selectedNodes.length === 0 ) {\n        return;\n      }\n\n      let selectedNode = selectedNodes[0];\n      this.appendTempNode( selectedNode, direction );\n    }\n    else if( isMoveNode ) {\n      let isEditingNode = this.nodeList.filter((d) => {\n        return d._isEdit;\n      }).length > 0;\n\n      if( !isEditingNode ) {\n        this.moveSelectNode( MOVE_DIRECTION[selectedKey] );\n        e.preventDefault();\n      }\n    }\n  }\n  onClickAddNode(direction) {\n    let selectedNodes = this.getSelectedNodes();\n    if( selectedNodes === null || selectedNodes.length === 0 ) {\n      return;\n    }\n\n    let selectedNode = selectedNodes[0];\n    this.appendTempNode( selectedNode, direction );\n  }\n  createNodeData( nodeObj ) {\n    return d3.hierarchy( nodeObj, (d) => {\n      return d.children;\n    });\n  }\n  initNodeData( jsonData ) {\n    this.nodes = this.createNodeData( jsonData );\n    this.nodeList = this.nodes.descendants();\n    this.nodeList = this.nodeList.map((d) => {\n      d._isShow = true;\n      d._isEdit = false;\n      d._isDragging = false;\n      return d;\n    });\n  }\n  updateNodesLayout() {\n    let isInitialLayout = this.$svg.attr('width') === null;\n\n    //各子ノードに対して、親からのインデックス番号を保持する\n    /*\n    node.childIndex = 0\n     |- node.childIndex = 0\n     |- node.childIndex = 1\n     |- node.childIndex = 2\n        |- node.childIndex = 0\n        |- node.childIndex = 1\n    */\n    this.setChildProperties( this.nodes, 0, true );\n\n    // 各親ノードに対して、自分の子孫に存在する葉っぱの数を保持する。子→親の順番で保持する。\n    /*\n    node.leafLength = 3\n     |- node.leafLength = 0 -- leave\n     |- node.leafLength = 0 -- leave\n     |- node.leafLength = 2\n        |- node.leafLength = 0 -- leave\n        |- node.leafLength = 0 -- leave\n    */\n    this.nodes.leaves().map((node) => {\n      this.setLeafLength( node );\n    });\n\n    this.nodeList.map((node) => {\n      // ノード名が長い場合に３点リーダー表示用プロパティ（ellipsisName）を設定する\n      this.setNodeNameProperties(node);\n      //各ノードに対して、縦方向の位置情報（インデックス番号）を割り当てる。親→子の順番で割り当てる。\n      this.setVerticalIndex(node);\n    });\n\n    //各ノードのx,y座標を算出\n    this.nodeList.map((d) => {\n      d._x = d.depth * this.columnWidth;\n      d._y = d._verticalIndex * this.rowHeight;\n    });\n\n    this.columnCount = d3.max( this.nodeList, (d) => {\n      return d.depth;\n    }) + 1;\n    this.rowCount = d3.max( this.nodeList, (d) => {\n      return d._verticalIndex;\n    }) + 1;\n\n    this.svgWidth = this.columnCount * this.columnWidth;\n    this.svgHeight = this.rowCount * this.rowHeight + MARGIN.CONTAINER.BOTTOM;\n\n    if( isInitialLayout ) {\n      this.$svg\n        .attr('width', this.svgWidth )\n        .attr('height', this.svgHeight );\n    }else {\n      this.$svg\n        .transition()\n        .duration(DEFAULT_DURATION)\n        .attr('width', this.svgWidth )\n        .attr('height', this.svgHeight );\n    }\n\n    this.updateBackground();\n  }\n  calculateNodePathD (d) {\n    if (!d || !d.parent) {\n      return\n    }\n    let margin = MARGIN.NODE.LEFT\n    let currentY = d._y\n    let parentY = d.parent._y\n    let diffY = currentY - parentY\n    if (diffY === 0) {\n      return 'M0,0 h10'\n    } else {\n      return `M0,${-(diffY)} q${margin/2},0,${margin/2},5 v${diffY-10} q0,${margin/2},${margin/2},${margin/2}`\n    }\n  }\n  /*\n  子ノードのレイアウト設定処理。全ての子ノードに対して再帰的に実行する。\n\n  @param node (Uo) ノード情報\n  @param childIndex (int) 親ノードを基準のした場合のノードの位置インデックス\n  @param isShow (Boolean) ノードを表示する場合はtrue、そうでない場合はfalse\n  */\n  setChildProperties(node, childIndex, isShow) {\n    let children = this.getChildren(node);\n    node._childIndex = childIndex;\n    node._isShow = isShow;\n    node._isTemp = !!node.data._isTemp;\n\n    if( children && children.length > 0 ) {\n      node._childrenLength = children.length;\n\n      //親が閉じられている場合は全ての子ノードを非表示にする\n      if( node._isToggleOpen === false ) {\n        isShow = false;\n      }\n\n      for( let i = 0, len = children.length; i < len; i++ ) {\n        this.setChildProperties( children[i], i, isShow );\n      }\n    }else {\n      node._childrenLength = 0;\n    }\n  }\n  setLeafLength(node) {\n    if( !this.hasChildren(node) ) {\n      node._leafLength = 0;\n    }else {\n      // 表示されているノードのみ葉っぱの個数に含める\n      let showChildren = node.children.filter((d) => {\n        return d._isShow;\n      });\n      let leafLength = showChildren.length;\n\n      // 子ノードの葉っぱの数を自分の葉っぱの数に加える\n      showChildren.map((n) => {\n        if( n._leafLength > 0 ) {\n          leafLength += n._leafLength - 1; //最初の子は親と同じy座標に位置するため-1する\n        }\n      });\n      node._leafLength = leafLength;\n    }\n    if( node.parent !== null ) {\n      this.setLeafLength( node.parent );\n    }\n  }\n  setNodeNameProperties(node) {\n    //名前用text要素からサイズをキャッシュしておき、他要素のレイアウトの計算に使用する。\n    // let nameSize = this.measureTextSize( this.getLineBreakTexts( node ) );\n    let nameSize = new Util().measureTextSize( node.data.name, this.$svg );\n    node._nameWidth = nameSize.width;\n    node._nameHeight = nameSize.height;\n    \n    //項目名が長い（２行以上表示される）場合に省略表示を行う\n    let strEachLine = this.splitStringEachLine( node.data.name );\n    node._ellipsisName = strEachLine[0];\n    node._isEllpsis = strEachLine.length > 1;\n    if( node._isEllpsis ) {\n      node._ellipsisName += '...';\n    }\n  }\n  setVerticalIndex(node) {\n    let verticalIndex = 0;\n\n    if( node.parent === undefined || node.parent === null ) {\n      //ルートノードの場合は一番上に表示する\n      verticalIndex = 0;\n    }\n    else if( node._childIndex === 0 || !node._isShow ) {\n      //長男ノードの場合は親の隣に位置するため、縦方向の位置は同じ\n      verticalIndex = node.parent._verticalIndex;\n    }\n    else if( node.parent.children !== null ) {\n      //兄弟ノードの場合は自分の兄の縦方向の１つ下の位置\n      node.parent.children.map((brotherNode) => {\n        if(brotherNode._childIndex === node._childIndex - 1) {\n          //兄弟ノードの縦位置と葉っぱノードの数の合計\n          verticalIndex = brotherNode._verticalIndex + Math.max(brotherNode._leafLength - 1, 0) + 1;\n        }\n      });\n    }\n    node._verticalIndex = verticalIndex;\n  }\n  updateBackground() {\n    if( this.$background === undefined ) {\n      this.$background = this.$svg.append('g')\n        .attr('class', 'tree-bg')\n        .on('click', () => {\n          this.blurNode();\n        });\n    }\n\n    let $rects = this.$background.selectAll('rect');\n    let currentRectCount = $rects.data().length;\n    let needRectCount = Math.ceil(this.svgWidth / this.columnWidth);\n\n    if( currentRectCount < needRectCount ) {\n      // 不足分の背景を加える\n      for( let i = currentRectCount; i < needRectCount; i++ ) {\n        this.$background.append('rect')\n          .attr('data-index', i)\n          .attr('width', this.columnWidth)\n          .attr('height', this.svgHeight)\n          .attr('x', i * this.columnWidth)\n          .attr('y', 0);\n      }\n    }else if( currentRectCount > needRectCount ) {\n      // 余分がある場合は削除する\n      $rects.each(function(d) {\n        let $rect = d3.select(this);\n        let index = $rect.attr('data-index');\n        if( index >= needRectCount ) {\n          $rect.remove();\n        }\n      });\n    }\n\n    $rects\n      .transition()\n      .duration(DEFAULT_DURATION)\n      .attr('width', this.columnWidth)\n      .attr('height', this.svgHeight);\n  }\n  initLayout() {\n    this.$nodeWrap = this.$svg.append('g')\n      .attr('transform', 'translate(0, ' + MARGIN.CONTAINER.TOP + ')');\n  }\n  showTooltip($nodeName, nodeData) {\n    if( !nodeData._isEllpsis ) {\n      return;\n    }\n\n    let tooltipMargin = {\n      left: 10,\n      top: 5\n    };\n\n    let $tooltip = this.$svgWrap\n      .append('div')\n      .attr('class', 'node-tooltip');\n\n    let $tooltipText = $tooltip\n      .append('p')\n      .attr('class', 'node-tooltip-text')\n      .text(nodeData.data.name);\n\n    let tooltipHeight = $tooltip.node().clientHeight;\n    let tooltipTop = nodeData._y + MARGIN.CONTAINER.TOP - this.rowHeight / 2 - tooltipHeight - tooltipMargin.top;\n\n    $tooltip\n      .attr('style', `left:${nodeData._x + tooltipMargin.left}px; top:${tooltipTop}px;`);\n  }\n  hideTooltip() {\n    let $tooltip = this.$svgWrap.selectAll('.node-tooltip').remove();\n  }\n  updateUserInputNode(node) {\n    let _this = this;\n    let maxLeafCount;\n    let minLeafCount;\n\n    this.nodes.each((d) => {\n      maxLeafCount = d.data.maximum_leaf_count || -1,\n      minLeafCount = d.data.minimum_leaf_count || -1;\n\n      if( maxLeafCount < 0 || minLeafCount < 0 ) {\n        return true;\n      }\n\n      let inputNodeData = _this.createNodeData({\n        id: this.createNodeId(),\n        name: '回答者が入力',\n        children: null\n      });\n      // 回答者入力ノードフラグ\n      inputNodeData._isUserInput = true;\n      this.insertChild( d, inputNodeData, 0 );\n    });\n\n    this.nodeList = this.nodes.descendants();\n  }\n  // ノードのドラッグ移動開始\n  startDragging(target) {\n    this.$dragNode = d3.select(target);\n    let dragNodeData = this.$dragNode.data()[0];\n    this.setPropertyForNode( dragNodeData, '_isDragging', true );\n    this.focusNode(dragNodeData);\n  }\n  // ノードのドラッグ中処理\n  doDragging() {\n    let dragNodeData = this.$dragNode.data()[0];\n    if( dragNodeData.depth === 0 || dragNodeData._isUserInput ) {\n      return;\n    }\n\n    if( !this.$svgWrap.classed('is-dragging') ) {\n      this.appendDragLayer();\n    }\n    if( this.$dummyNode ) {\n      this.$dummyNode.attr('transform', `translate(${d3.event.x}, ${d3.event.y})`);\n    }else {\n      this.createDummyNode();\n    }\n  }\n  createDummyNode() {\n    this.$dummyNode = new Util().copySelection( this.$dragNode, this.$nodeWrap )\n      .attr('class', 'node--drag')\n      .attr('opacity', '0.5')\n      // dragAreaのmouseoverを検知できるようにdummyNodeのマウスイベントを無効化\n      .attr('pointer-events', 'none');\n\n    this.$dummyNode\n      .attr('data-init-transform', this.$dummyNode.attr('transform'));\n  }\n  appendDragLayer() {\n    let _this = this;\n    let dragNodeData = this.$dragNode.data()[0];\n\n    let overDragArea = function(d) {\n      d3.select(this).classed('is-selected', true);\n    };\n    let outDragArea = function(d) {\n      d3.select(this).classed('is-selected', false)\n    };\n    let setDragAreaProperties = function($dragArea) {\n      $dragArea\n        .attr('class', 'tree-dragarea')\n        .classed('is-disabled', function(d) {\n          // ノードは兄弟ノード間のみ移動できるようにする\n          let $target = d3.select(this);\n          let layoutIndex = parseInt($target.attr('data-childindex'));\n          let isBrothers = d.parent === dragNodeData.parent;\n          let isYoungBrother = isBrothers && dragNodeData._childIndex === layoutIndex - 1;\n          let isSamePosition = isYoungBrother || d._isDragging;\n          // let isDisabled = !isBrothers || isSamePosition || d._isUserInput;\n          let isDisabled = isSamePosition || d._isUserInput;\n\n          return isDisabled;\n        })\n        .attr('width', _this.columnWidth)\n        .attr('data-depth', (d) => {\n          return d.depth;\n        })\n        .attr('data-parentid', (d) => {\n          return d.parent ? d.parent.data.id : -1;\n        })\n        .on('mouseover', overDragArea)\n        .on('mouseout', outDragArea);\n    };\n    let appendChildren = function( $dragArea, isLast ) {\n      $dragArea.append('rect')\n        .attr('width', _this.columnWidth)\n        .attr('height', (d) => {\n          return getLayerHeight(d, isLast);\n        });\n      $dragArea.append('line')\n        .attr('x1', 0)\n        .attr('y1', (d) => {\n          return getLineY(d, isLast);\n        })\n        .attr('x2', $dragArea.attr('width'))\n        .attr('y2', (d) => {\n          return getLineY(d, isLast);\n        });\n    };\n    let getLayerHeight = function(d, isLast) {\n      let dragAreaHeight = 0;\n      let isFirst = d._childIndex === 0;\n      let isTop = d._verticalIndex === 0;\n\n      if(isFirst) {\n        dragAreaHeight = _this.rowHeight / 2;\n        // if( !isTop ) {\n        //   // ノードより上をドラッグ可能領域とする\n        //   dragAreaHeight += _this.svgHeight - ( _this.svgHeight - d._y );\n        // }\n      }\n      else if(isLast) {\n        // ノードより下の領域をドラック可能領域とする\n        dragAreaHeight = _this.svgHeight - d._y - (_this.rowHeight / 2);\n      }\n      else {\n        // ノード間をドラッグ可能領域とする\n        let brotherNode = _this.getChildren(d.parent)[d._childIndex - 1];\n        dragAreaHeight = d._y - brotherNode._y;\n      }\n      return dragAreaHeight;\n    };\n    let getLineY = function(d, isLast) {\n      let isFirst = d._childIndex === 0;\n      let lineY = 0;\n\n      if( isFirst && isLast ) {\n        lineY = _this.rowHeight / 2;\n      }\n      else if( isFirst ) {\n        // lineY = d._y;\n        lineY = 0;\n      }\n      else if( isLast ) {\n        lineY = _this.rowHeight / 2;\n      }\n      else {\n        lineY = getLayerHeight(d, isLast) - _this.rowHeight / 2;\n      }\n      return lineY;\n    }\n\n    let $dragArea = this.$nodeWrap.selectAll('.node')\n      .append('g')\n      .classed('is-first', (d) => {\n        return d._childIndex === 0;\n      })\n      .attr('transform', (d) => {\n        return `translate(0, ${ -(getLayerHeight(d)) })`;\n      })\n      .attr('data-childindex', (d) => {\n        return d._childIndex;\n      })\n      .call( setDragAreaProperties )\n      .call(($dragArea) => {\n        appendChildren( $dragArea, false );\n      });\n\n    let $lastdragArea = this.$nodeWrap.selectAll('.node--youngest')\n      .append('g')\n      .classed('is-last', true)\n      .attr('transform', 'translate(0,0)')\n      .attr('data-childindex', (d) => {\n        return d._childIndex + 1;\n      })\n      .call( setDragAreaProperties )\n      .call(($dragArea) => {\n        appendChildren( $dragArea, true );\n      });\n\n    $dragArea = this.$nodeWrap.selectAll('.tree-dragarea');\n    this.$svgWrap.classed('is-dragging', true);\n  }\n  // ノードのドラッグ移動終了\n  endDragging() {\n    let $selectedDragArea = d3.select('.tree-dragarea.is-selected');\n    let exitFunc = () => {\n      if (!this.$dragNode) {\n        return;\n      }\n      let dragNodeData = this.$dragNode.data()[0];\n\n      this.$nodeWrap.selectAll('.tree-dragarea').remove();\n      this.$svgWrap.classed('is-dragging', false);\n      this.setPropertyForNode( dragNodeData, '_isDragging', false );\n\n      this.$dummyNode = null;\n      this.$svg.selectAll('.node--drag').remove();\n      this.$dragNode = null;\n    };\n\n    if( this.$dummyNode === undefined || this.$dummyNode === null ) {\n      exitFunc();\n      return;\n    }\n\n    if( $selectedDragArea.data().length > 0 ) {\n      let moveNode = this.$dragNode.data()[0]; \n      let toParentId = parseInt($selectedDragArea.attr('data-parentid'));\n      let toChildIndex = parseInt($selectedDragArea.attr('data-childindex'));\n      let toDepth = parseInt($selectedDragArea.attr('data-depth'));\n      let isMovedNode = this.isMovedNode( moveNode, toParentId, toChildIndex, toDepth );\n\n      if( isMovedNode ) {\n        // ノードの移動を実行して処理を終了する\n        this.updateNode({\n          type: NODE_METHOD.MOVE_NODE,\n          data: {\n            moveNode: this.$dragNode.data()[0],\n            toParentId: toParentId,\n            toChildIndex: toChildIndex,\n            toDepth: toDepth\n          }\n        });\n        exitFunc();\n        return;\n      }\n    }\n    // 移動しない場合はダミーノードを元の位置に戻し、削除する\n    this.$dummyNode\n      .transition()\n      .duration( DEFAULT_DURATION )\n      .attr( 'transform', this.$dummyNode.attr('data-init-transform') )\n      .on('end', () => {\n        exitFunc();\n      });\n  }\n  // 項目名の改行を行なった結果をHTML要素に変換して返す\n  getLineBreakTexts(node) {\n    let lineHeight = 1.5;\n    let textHtml = '';\n    let strEachLine = this.splitStringEachLine( node.data.name );\n\n    strEachLine.forEach((text, index) => {\n      textHtml += '<tspan class=\"line line' + index + '\" x=\"0\" y=\"' + (index * lineHeight) + 'em\" dx=\"0.6em\" dy=\"0.35em\">' + text + '</tspan>'\n    });\n    return textHtml;\n  }\n  // ノード名複数行対応：行ごとの文字列に分割した配列を作成する\n  splitStringEachLine(str) {\n    let strEachLine = [];\n    let lineCount = 0;\n    let strLength\n\n    for( let i = 0, len = str.length; i < len; i++ ) {\n      let chara = str[i];\n      if( strEachLine.length <= lineCount ) {\n        strEachLine.push('');\n      }\n      strEachLine[lineCount] += chara;\n\n      // 1行内の文字数が一定数より多い場合は改行の可能性がある（一定数＝全角文字で１行に必ず入る文字数）\n      let isPossibilityLineBreak = strEachLine[lineCount].length > this.textMinLength;\n      if( isPossibilityLineBreak ) {\n        // 文字幅が１行に表示できる文字を超えている場合は改行\n        let strSize = new Util().measureTextSize( strEachLine[lineCount], this.$svg );\n        if( strSize.width >= this.textLineWidth ) {\n          ++lineCount;\n        }\n      }\n    }\n    return strEachLine;\n  }\n  initNode() {\n    this.$nodes = this.createNode( this.nodeList );\n    this.updateParentNode();\n  }\n  updateParentNode() {\n    this.updateLineToChild();\n    this.updateToggleChildren();\n  }\n  // 親ノードが子を持っているか確認する\n  hasChildren(node) {\n    let children = this.getChildren(node);\n    return children && children.length > 0;\n  }\n  // 親ノードの子を取得する\n  getChildren(node) {\n    return node.children;\n  }\n  // 親ノードの子に指定されたノードを挿入する\n  insertChild(parentNode, insertNode, childIndex) {\n\n    if( this.hasChildren( parentNode ) ) {\n      let children = this.getChildren( parentNode );\n\n      if( childIndex === undefined || children.length <= childIndex ) {\n        children.push( insertNode );\n        parentNode.data.children.push( insertNode.data );\n      }else {\n        children.splice( childIndex, 0, insertNode );\n        parentNode.data.children.splice( childIndex, 0, insertNode.data );\n      }\n    }\n    else {\n      parentNode.children = [insertNode];\n      parentNode.data.children = [insertNode];\n    }\n    insertNode.parent = parentNode;\n    this.setPropertyForNode( insertNode, 'depth', parentNode.depth + 1, (val) => {\n      return val + 1;\n    });\n  }\n  /*\n  ノードの子孫も含めて任意のプロパティを更新する\n  @param node (Object) 更新の対象となるノードデータ\n  @param propertyName (String) プロパティ名\n  @param value (anything) 値\n  @param recursive (function) 子孫へ再起的に実行する際にvalueに対して何かしら処理を行う際に使用する\n  */\n  setPropertyForNode(node, propertyName, value, recursive) {\n    node[propertyName] = value;\n\n    if( !this.hasChildren( node ) ) {\n      return;\n    }\n    let children = this.getChildren( node );\n\n    if( typeof recursive === 'function' ) {\n      value = recursive(value);\n    }\n\n    for( let i = 0, len = children.length; i < len; i++ ) {\n      this.setPropertyForNode( children[i], propertyName, value, recursive );\n    }\n  }\n  /*\n  ノード作成・更新時に共通のプロパティを設定する処理\n  */\n  setCommonPropetiesForNode($nodes) {\n    $nodes\n      .classed('node--oldest', (d) => {\n        return d._childIndex === 0;\n      })\n      .classed('node--youngest', (d) => {\n        return d.parent && d._childIndex === this.getChildren(d.parent).length - 1;\n      })\n      .classed('node--branch', (d) => {\n        let children = [];\n        // let leafs = [];\n\n        if( this.hasChildren(d) ) {\n          children = this.getChildren(d);\n          // leafs = children.filter((d) => {\n          //   return !this.hasChildren(d);\n          // });\n        }\n        return children.length > 0;\n      })\n      .classed('node--leaf', (d) => {\n        return !this.hasChildren(d);\n      })\n      .classed('node--other', (d) => {\n        // 子は存在するが、葉を１つも持っていないノード\n        let hasChildren = this.getChildren(d);\n        let hasLeaf = false;\n        if( this.hasChildren(d) ) {\n          this.getChildren(d).map((d) => {\n            if( !this.hasChildren(d) ) {\n              hasLeaf = true;\n              return false;\n            } \n          });\n        }\n        return hasChildren && !hasLeaf;\n      })\n      .classed('node--userinput', (d) => {\n        return d._isUserInput;\n      })\n      .classed('is-close', false)\n  }\n  // ノードを追加する際に新しいIDを作成する\n  createNodeId() {\n    let maxId = d3.max( this.nodes.descendants(), (d) => {\n      return d.data.id;\n    });\n    return ++maxId;\n  }\n  // ノード作成処理\n  createNode(dataSet) {\n    let _this = this;\n\n    let $nodes = this.$nodeWrap.selectAll('.node')\n      .data( dataSet, (d) => {\n        return d.data.id;\n      })\n      .enter()\n      .append('g')\n      .attr('class', (d) => {\n        return 'node';\n      })\n      .call( this.setCommonPropetiesForNode.bind(this) )\n      .attr('width', this.columnWidth)\n      .attr('height', this.nodeHeight)\n      .attr('opacity', 1)\n      .attr('transform', function(d) {\n        return 'translate(' + (d._x) + ', ' + (d._y) + ')';\n      });\n\n    //背景に敷くためのrect要素を先に要素追加しておき、後でプロパティを設定する\n    let $nodesBg = $nodes.append('rect');\n\n    //ノード名の左側に表示するアイコン\n    // let $nodeHead = $nodes.append('circle')\n    //   .attr('r', 3);\n\n    //ノード名用text要素\n    let $nodeText = $nodes.append('text')\n      .attr('class', 'node-name')\n      .attr('x', MARGIN.NODE_NAME.LEFT)\n      .attr('y', '0.35em')\n      .text((d) => {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n    // 親ノードと子ノードを繋ぐためのパス\n    let $nodePath = $nodes.append('path')\n      .attr('class', 'node-path')\n      .attr('d', this.calculateNodePathD)\n      .attr('fill', 'none');\n\n    //背景用rect要素のプロパティを設定\n    //ノードドラッグ時に発生させたくないイベントはこのSelectionにバインドする\n    $nodesBg.attr('height', (d) => {\n      return d._nameHeight;\n    })\n    .attr('class', 'node-bg')\n    .attr('width', this.columnWidth - MARGIN.NODE.LEFT)\n    .attr('height', this.nodeHeight)\n    .attr('x', MARGIN.NODE.LEFT)\n    .attr('y', -(this.nodeHeight / 2) )\n    .attr('fill', 'transparent')\n    .on('mouseover', function(d) {\n      if( _this.$svgWrap.classed('is-dragging') ) {\n        return;\n      }\n      _this.showTooltip(d3.select(this), d);\n    })\n    .on('mouseout', (d) => {\n      this.hideTooltip();\n    })\n    .on('click', (d) => {\n      _this.focusNode(d);\n    })\n    .on('dblclick', (d) => {\n      _this.editStartNodeName( d );\n    });\n\n    $nodes.each(function(d) {\n      if( !d._isUserInput ) {\n        //回答者入力欄以外はドラッグ＆ドロップで移動可能にする\n        d3.select(this)\n          .call(\n            d3.drag()\n            .on('start', function() {\n              _this.startDragging(this);\n            })\n            .on('drag', () => {\n              _this.doDragging();\n            })\n            .on('end', () => {\n              _this.endDragging();\n            })\n          );\n      }else {\n        //回答者入力ノード用ラベル\n        d3.select(this)\n          .append('text')\n          .attr('class', 'node--userinput-range')\n          .attr('x', _this.columnWidth - 10)\n          .attr('y', '0.35em')\n          .attr('text-anchor', 'end')\n          .text((d) => {\n            let maxLeafCount = d.parent.data.maximum_leaf_count;\n            let minLeafCount = d.parent.data.minimum_leaf_count;\n            return `${minLeafCount}〜${maxLeafCount}`;\n          })\n        };\n    });\n\n    return $nodes;\n  }\n  // ノード更新処理\n  updateNode( param ) {\n    var _this = this;\n\n    if( param ) {\n      switch( param.type ) {\n        case NODE_METHOD.UPDATE_NAME:\n          // 指定されたパラメータを元に内部データを更新する\n          this.nodeList.map( (node) => {\n            if( param.data.id !== node.data.id ) return true;\n            for( let key in param.data ) {\n              node.data[key] = param.data[key];\n            }\n            this.setNodeNameProperties(node);\n          });\n          break;\n        case NODE_METHOD.TOGGLE_CHILDREN:\n          const node = param.data.node\n          if( node._isToggleOpen === undefined ) {\n            node._isToggleOpen = false;\n          }else {\n            node._isToggleOpen = !node._isToggleOpen;\n          }\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.DELETE_NODE:\n          //ルートノードは削除できない\n          if( param.data.deleteNode.depth === 0 ) {\n            return;\n          }\n\n          // 対象ノードをデータから削除し、各ノードの位置を再計算する。\n          this.deleteNodeData( param.data.deleteNode, param.confirm );\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.APPEND_NODE_TEMP:\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.MOVE_NODE:\n          let {data} = param;\n          let {moveNode, toParentId, toChildIndex, toDepth} = data;\n          let isSameParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n          let isYounger = moveNode._childIndex < toChildIndex;\n\n          if( isSameParent && isYounger ) {\n            --toChildIndex;\n          }\n\n          if( !this.isMovedNode( moveNode, toParentId, toChildIndex, toDepth ) ) {\n            return;\n          }\n\n          //ノードリストから対象のノードを取り除く\n          this.deleteNodeData( moveNode );\n\n          //対象ノードを移動先の位置に加える\n          this.nodes.each((d) => {\n            if( d.data.id !== toParentId ) {\n              return true;\n            }\n            this.insertChild( d, moveNode, toChildIndex );\n            return false;\n          });\n\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n      }\n    }\n\n    let $newNode = this.createNode( this.nodeList );\n\n    // 内部データを元に各ノードの状態を更新する\n    this.$nodes = this.$nodeWrap.selectAll('.node')\n      .data( this.nodeList, (d) => {\n        // idをもとに変更前と変更後のノード情報を紐づける\n        return d.data.id;\n      })\n      .call( this.setCommonPropetiesForNode.bind(this) )\n      .transition()\n      .on('end', function(d) {\n        // アニメーションが終わった後にノードを非表示にする\n        if( !d._isShow ) {\n          d3.select(this).classed('is-close', true);\n        }\n      })\n      .duration(DEFAULT_DURATION)\n      .attr('opacity', (d) => {\n        return d._isShow ? 1 : 0;\n      })\n      .attr('transform', (d) => {\n        return `translate(${d._x}, ${d._y})`;\n      });\n    \n    let $delNodes = this.$nodeWrap.selectAll('.node')\n      .data( this.nodeList, (d) => {\n        return d.data.id;\n      })\n      .exit()\n      .remove();\n\n    let $texts = this.$nodes.selectAll('.node-name')\n      .text((d) => {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n    this.$nodeWrap.selectAll('.node-path')\n      .transition()\n      .duration(DEFAULT_DURATION)\n      .attr('d', this.calculateNodePathD);\n\n    if( $newNode !== undefined && $newNode !== null && $newNode.data().length > 0 ) {\n      //内部データを更新した後、追加されたノードは編集状態にする\n      let newNodeData = $newNode.data()[0];\n      this.editStartNodeName( newNodeData );\n      this.focusNode(newNodeData);\n    }\n\n    this.updateParentNode();\n  }\n  focusNode( selectNodes ) {\n    let selectIds = [];\n\n    if( Array.isArray( selectNodes ) ) {\n      selectNodes.map((d) => {\n        selectIds.push( d.data.id );\n      });\n    }else {\n      selectIds.push( selectNodes.data.id );\n    }\n\n    this.$nodes.each(function(d) {\n      let $node = d3.select(this);\n      let isSelected = selectIds.indexOf(d.data.id) > -1;\n      $node.classed('is-selected', isSelected);\n    });\n  }\n  blurNode() {\n    this.$nodes.each(function(d) {\n      d3.select(this).classed('is-selected', false);\n    });\n  }\n  moveSelectNode(move_direction) {\n    let selectedNodes = this.getSelectedNodes();\n    if( selectedNodes === null || selectedNodes.length === 0 ) {\n      return;\n    }\n    let selectedNode = selectedNodes[0];\n    let {_childIndex, depth} = selectedNode;\n    let newSelectNodes;\n    let cousinNodes;\n\n    switch( move_direction ) {\n      case MOVE_DIRECTION.TOP:\n        cousinNodes = this.nodeList.filter((d) => {\n          return selectedNode.depth === d.depth && selectedNode._verticalIndex > d._verticalIndex;\n        });\n        newSelectNodes = cousinNodes.length > 0 ? cousinNodes[ cousinNodes.length - 1 ] : undefined;\n        break;\n      case MOVE_DIRECTION.LEFT:\n        newSelectNodes = selectedNode.parent ? [selectedNode.parent] : undefined;\n        break;\n      case MOVE_DIRECTION.BOTTOM:\n        cousinNodes = this.nodeList.filter((d) => {\n          return selectedNode.depth === d.depth && selectedNode._verticalIndex < d._verticalIndex;\n        });\n        newSelectNodes = cousinNodes.length > 0 ? cousinNodes[0] : undefined;\n        break;\n      case MOVE_DIRECTION.RIGHT:\n        newSelectNodes = this.nodeList.filter((d) => {\n          return selectedNode === d.parent && d._childIndex === 0 && d.depth === depth + 1;\n        });\n        break;\n    }\n\n    if( newSelectNodes === undefined || newSelectNodes.length === 0 ) {\n      return;\n    }\n\n    this.focusNode(newSelectNodes);\n  }\n  getSelectedNodes() {\n    let selectedNodes = this.$nodeWrap.select('.node.is-selected').data();\n    if( selectedNodes === undefined && selectedData.length === 0 ) {\n      return null;\n    }\n    return selectedNodes;\n  }\n  deleteSelectedNode() {\n    let selectedNodes = this.getSelectedNodes();\n\n    for( let i = 0, len = selectedNodes.length; i < len; i++ ) {\n      this.deleteNode( selectedNodes[i] );\n    }\n  }\n  // ツリーに表示されているノードを削除する\n  deleteNode(node) {\n    //編集中には削除処理を実行しない\n    if( node._isEdit ) {\n      return;\n    }\n\n    this.updateNode({\n      type: NODE_METHOD.DELETE_NODE,\n      data: {\n        deleteNode: node\n      },\n      confirm: (deleteNode) => {\n        // 確認処理を行い、キャンセルした場合は処理を中断する。\n        let hasChildren = this.getChildren(deleteNode) && this.getChildren(deleteNode).length > 0;\n        let doDelete = true;\n\n        if( hasChildren ) {\n          doDelete = confirm('子階層のノードも削除されますが、本当に削除してもよろしいですか？');\n        }\n        return doDelete;\n      }\n    });\n  }\n  // 内部ノード情報から対象のノードを削除する\n  deleteNodeData(node, confirmFunction) {\n    let deleteNode = null;\n    let parentNode = null;\n\n    this.nodes.each((d) => {\n      if( node === d ) {\n        deleteNode = d;\n        parentNode = d.parent;\n        return false;\n      }\n    });\n\n    // 確認処理を行い、キャンセルした場合は処理を中断する。\n    let doConfirm = confirmFunction && typeof confirmFunction === 'function';\n    if( doConfirm && !confirmFunction(deleteNode) ) {\n      return;\n    }\n\n    parentNode.children.map((d, i) => {\n      if( d !== deleteNode ) {\n        return true;\n      }\n      parentNode.children.splice(i, 1);\n    });\n  }\n  editStartNodeName( node ) {\n    let _this = this;\n    let $node;\n\n    if( node._isUserInput ) {\n      return;\n    }\n\n    this.$nodes.each(function(d) {\n      if( d.data.id === node.data.id ) {\n        $node = d3.select(this);\n        return false;\n      }\n    });\n\n    node._isEdit = true;\n    $node.classed('is-editing', true);\n\n    //テキストボックスを生成し、編集状態にする\n    let $inputNode = this.$svgWrap.append('input')\n      .attr('type', 'text')\n      .attr('value', node.data.name)\n      .attr('class', 'node-textbox')\n      .attr('style', `left:${node._x + MARGIN.NODE.LEFT}px; top:${node._y + MARGIN.CONTAINER.TOP - this.nodeHeight / 2}px; width:${this.columnWidth - MARGIN.NODE.LEFT}px; height:${this.nodeHeight}px;`)\n      .on('blur', function() {\n        let isEmpty = this.value.trim() === '';\n        let newNodeName = d3.select(this).node().value;\n\n        //テキストボックスからフォーカスが外れた場合は元のラベルを更新する\n        node._isEdit = false;\n        $node.classed('is-editing', false);\n        _this.$svgWrap.selectAll('.node-textbox').remove();\n\n        if( isEmpty ) {\n          if( node._isTemp ) {\n            //ノード追加時の場合は追加前の状態に戻す\n            _this.deleteNode( node );\n            return;\n          }else {\n            //空文字の場合は元の名前に戻す\n            newNodeName = node.data.name;\n          }\n        }\n\n        _this.updateNode({\n          type: NODE_METHOD.UPDATE_NAME,\n          data: {\n            id: node.data.id,\n            name: newNodeName\n          }\n        });\n      });\n\n    $inputNode.node().focus();\n  }\n  editEndNodeName() {\n    let $inputNode = this.$svgWrap.selectAll('.node-textbox');\n    if( $inputNode.data().length === 0 ) {\n      return;\n    }\n    $inputNode.node().blur();\n\n    this.updateLineToChild();\n  }\n  isMovedNode(moveNode, toParentId, toChildIndex, toDepth) {\n    let someParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n    let someChildIndex = moveNode._childIndex === toChildIndex;\n    let someDepth = moveNode.depth === toDepth;\n    return !(someParent && someChildIndex && someDepth);\n  }\n  isNodeNameEmpty() {\n    let isEmpty = true;\n    let $inputNode = this.$svgWrap.selectAll('.node-textbox');\n    if( $inputNode.data().length === 0 ) {\n      return isEmpty;\n    }\n    isEmpty = $inputNode.node().value.trim() === '';\n    return isEmpty;\n  }\n  appendTempNode( selectedNode, direction ) {\n\n    if( selectedNode._isEdit ) {\n      if( !this.isNodeNameEmpty() ) {\n        this.editEndNodeName();\n      }\n      return;\n    }\n    else if( selectedNode._isUserInput && direction === APPEND_DIRECTION.RIGHT ) {\n      return;\n    }\n\n    let parentNode = selectedNode.parent;\n    if( parentNode === null && direction === APPEND_DIRECTION.BOTTOM ) {\n      //ルート階層の下にノードは追加できないようにする\n      return;\n    }\n\n    // ノード追加を行うための一時ノードを生成してツリーに加える\n    let tempNodeData = this.createNodeData({\n      id: this.createNodeId(),\n      name: '',\n      children: null,\n      _isTemp: true\n    });\n\n    switch( direction ) {\n      case APPEND_DIRECTION.RIGHT:\n        this.insertChild( selectedNode, tempNodeData );\n        break;\n      case APPEND_DIRECTION.BOTTOM:\n        this.insertChild( parentNode, tempNodeData, selectedNode._childIndex + 1 );\n        break;\n    }\n\n    this.updateNode({\n      type: NODE_METHOD.APPEND_NODE_TEMP\n    });\n  }\n  updateToggleChildren() {\n    let _this = this;\n    let circleRadius = 8;\n\n    this.$nodes.each(function(d) {\n      let $node = d3.select(this);\n      let isParent = _this.hasChildren(d);\n      let hasToggle = $node.select('.node-toggle').node() !== null;\n\n      if( isParent && !hasToggle ) {\n        let $toggle = $node.append('g')\n          .attr('class', 'node-toggle')\n          .attr('transform', `translate(${_this.columnWidth - circleRadius * 2}, 0)`)\n          .on('click', (d) => {\n            _this.toggleChildren(d);\n          });\n\n        let $circles = $toggle.append('circle')\n          .attr('r', circleRadius);\n\n        let $texts = $toggle.append('text')\n          .attr('class', 'node-toggle-label')\n          .attr('width', circleRadius * 2)\n          .attr('hegith', circleRadius * 2)\n          .attr('text-anchor', 'middle')\n          .attr('dy', circleRadius / 2)\n          .text( d._isToggleOpen === false ? '+' : '–' );\n      }\n      else if( isParent && hasToggle ) {\n        $node.select('.node-toggle-label')\n          .text( d._isToggleOpen === false ? '+' : '–' );\n      }\n      else if( !isParent && hasToggle ) {\n        $node.select('.node-toggle').remove();\n      }\n    });\n  }\n  updateLineToChild() {\n    let _this = this;\n\n    this.$svgWrap.selectAll('.node-branch-line').remove();\n    this.$svgWrap.selectAll('.node--other').each(function(d) {\n      let $node = d3.select(this);\n      let isParent = _this.hasChildren(d);\n      let hasLine = $node.select('.node-branch-line').node() !== null;\n\n      // if( isParent && !hasLine && !d._isEllpsis ) {\n      //   $node.append('line')\n      //     .attr('class', 'node-branch-line')\n      //     .attr('stroke', 'black')\n      //     .attr('stroke-width', 1)\n      //     .attr('stroke-dasharray', '1 4')\n      //     .attr('x1', d._nameWidth + MARGIN.NODE_NAME.LEFT + 10)\n      //     .attr('y1', 0)\n      //     .attr('x2', _this.columnWidth - 10)\n      //     .attr('y2', 0);\n      // }\n    });\n  }\n  toggleChildren( parentData ) {\n    this.updateNode({\n      type: NODE_METHOD.TOGGLE_CHILDREN,\n      data: {\n        node: parentData\n      }\n    });\n  }\n}\n\nclass Util {\n  measureTextSize(str, $container) {\n    let $text = $container.append('text')\n      .attr('class', 'temp-measure-text')\n      .html(str);\n    let bbox = $text.node().getBBox();\n    $text.remove();\n    return bbox;\n  }\n  copySelection( $target, $to ) {\n    let node = $target.node();\n    let {nodeName, attributes, children} = node;\n    let $copy = $to.append(nodeName);\n\n    Object.keys(attributes).forEach((key) => {\n      $copy.attr(attributes[key].name, attributes[key].value);\n    });\n    $copy.html($target.html());\n\n    return $copy;\n  }\n}\n\n(function() {\n  window.TreeUI = TreeUI;\n}())\n\n\n// WEBPACK FOOTER //\n// ./tree-ui.js"],"sourceRoot":""}