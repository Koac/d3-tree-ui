{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap e0a24043a405f5043d70","webpack:///./tree-ui.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","MARGIN","CONTAINER","TOP","BOTTOM","NODE","LEFT","NODE_NAME","NODE_METHOD","UPDATE_NAME","TOGGLE_CHILDREN","DELETE_NODE","APPEND_NODE_TEMP","MOVE_NODE","KEY_NUMBER","8","9","13","37","38","40","39","APPEND_DIRECTION","RIGHT","MOVE_DIRECTION","DirectoryTree","root","wrapper","this","$svgWrap","d3","select","$svg","$addNodeBottom","$addNodeRight","columnWidth","textLineWidth","textMinLength","rowHeight","nodeHeight","value","_this2","getJsonData","data","bindEvents","initNodeData","updateUserInputNode","updateNodesLayout","initLayout","initNode","callback","json","error","_this3","document","addEventListener","e","onKeydownView","on","onClickAddNode","selectedKey","which","isMoveNode","deleteSelectedNode","preventDefault","selectedNodes","getSelectedNodes","direction","selectedNode","appendTempNode","isEditingNode","nodeList","filter","_isEdit","moveSelectNode","nodeObj","hierarchy","children","jsonData","nodes","createNodeData","descendants","map","_isShow","_isDragging","_this4","isInitialLayout","attr","setChildProperties","leaves","node","setLeafLength","setNodeNameProperties","setVerticalIndex","_x","depth","_y","_verticalIndex","columnCount","max","rowCount","svgWidth","svgHeight","transition","duration","updateBackground","parent","margin","currentY","parentY","diffY","childIndex","isShow","getChildren","_childIndex","_isTemp","_childrenLength","_isToggleOpen","len","hasChildren","showChildren","leafLength","_leafLength","nameSize","Util","measureTextSize","_nameWidth","width","_nameHeight","height","strEachLine","splitStringEachLine","_ellipsisName","_isEllpsis","verticalIndex","undefined","brotherNode","Math","_this5","$background","append","blurNode","$rects","selectAll","currentRectCount","needRectCount","ceil","each","$rect","remove","$nodeWrap","$nodeName","nodeData","tooltipMargin","left","top","$tooltip","tooltipHeight","text","clientHeight","tooltipTop","_this6","_this","maxLeafCount","minLeafCount","maximum_leaf_count","minimum_leaf_count","inputNodeData","id","createNodeId","_isUserInput","insertChild","$dragNode","dragNodeData","setPropertyForNode","focusNode","classed","appendDragLayer","$dummyNode","event","x","y","createDummyNode","copySelection","overDragArea","outDragArea","setDragAreaProperties","$dragArea","$target","layoutIndex","parseInt","appendChildren","isLast","getLayerHeight","getLineY","dragAreaHeight","isFirst","_this7","$selectedDragArea","exitFunc","moveNode","toParentId","toChildIndex","toDepth","isMovedNode","updateNode","type","textHtml","forEach","index","str","lineCount","chara","push","$nodes","createNode","updateParentNode","updateLineToChild","updateToggleChildren","parentNode","insertNode","splice","val","propertyName","recursive","_this8","hasLeaf","maxId","dataSet","_this9","enter","setCommonPropetiesForNode","bind","$nodesBg","calculateNodePathD","showTooltip","hideTooltip","editStartNodeName","drag","startDragging","doDragging","endDragging","param","_this10","deleteNode","deleteNodeData","confirm","isSameParent","isYounger","$newNode","exit","newNodeData","selectNodes","selectIds","Array","isArray","$node","isSelected","indexOf","move_direction","newSelectNodes","cousinNodes","selectedData","_this11","_confirm","apply","arguments","toString","doDelete","confirmFunction","isEmpty","trim","newNodeName","focus","$inputNode","blur","someParent","someChildIndex","someDepth","isNodeNameEmpty","editEndNodeName","tempNodeData","isParent","hasToggle","$toggle","circleRadius","toggleChildren","parentData","$container","$text","html","bbox","getBBox","$to","nodeName","attributes","$copy","keys","init"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MARGIN = {\n  CONTAINER: {\n    TOP: 30,\n    BOTTOM: 50\n  },\n  NODE: {\n    LEFT: 10\n  },\n  NODE_NAME: {\n    LEFT: 20\n  }\n};\nvar DEFAULT_DURATION = 500;\n\n// ノード名の１行あたりの最大文字数（半角）\nvar NODE_NAME_LINE_MAX = 26;\n\n// ノード更新時のメソッド識別用\nvar NODE_METHOD = {\n  UPDATE_NAME: 'updateName',\n  TOGGLE_CHILDREN: 'toggleChildren',\n  DELETE_NODE: 'deleteNode',\n  APPEND_NODE_TEMP: 'appendNodeTemp',\n  MOVE_NODE: 'moveNode'\n};\n\nvar KEY_NUMBER = {\n  8: 'DELETE',\n  9: 'TAB',\n  13: 'ENTER',\n  37: 'LEFT',\n  38: 'TOP',\n  40: 'BOTTOM',\n  39: 'RIGHT'\n};\n\n// ノード追加時の位置\nvar APPEND_DIRECTION = {\n  BOTTOM: 'appendToBottom',\n  RIGHT: 'appendToRight'\n};\n\n// ノード移動時の位置\nvar MOVE_DIRECTION = {\n  TOP: 'moveTop',\n  LEFT: 'moveLeft',\n  BOTTOM: 'moveBottom',\n  RIGHT: 'moveRight'\n};\n\nvar DirectoryTree = function () {\n  function DirectoryTree(root, wrapper) {\n    _classCallCheck(this, DirectoryTree);\n\n    this.$svgWrap = d3.select(wrapper);\n    this.$svg = d3.select(root);\n    this.$addNodeBottom = d3.select('.js-tree-addnode-bottom');\n    this.$addNodeRight = d3.select('.js-tree-addnode-right');\n\n    this.columnWidth = 200;\n    this.textLineWidth = this.columnWidth - 50;\n    this.textMinLength = 10;\n    this.rowHeight = 35;\n    this.nodeHeight = 30;\n  }\n\n  _createClass(DirectoryTree, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      this.getJsonData(function (data) {\n        _this2.bindEvents();\n        _this2.initNodeData(data);\n        _this2.updateUserInputNode();\n        _this2.updateNodesLayout();\n        _this2.initLayout();\n        _this2.initNode();\n      });\n    }\n  }, {\n    key: 'getJsonData',\n    value: function getJsonData(callback) {\n      d3.json('./data/sample-data.json', function (error, data) {\n        if (error) throw error;\n        callback(data);\n      });\n    }\n  }, {\n    key: 'bindEvents',\n    value: function bindEvents() {\n      var _this3 = this;\n\n      document.addEventListener('keydown', function (e) {\n        _this3.onKeydownView(e);\n      });\n      this.$addNodeBottom.on('click', function (e) {\n        _this3.onClickAddNode(APPEND_DIRECTION.BOTTOM);\n      });\n      this.$addNodeRight.on('click', function (e) {\n        _this3.onClickAddNode(APPEND_DIRECTION.RIGHT);\n      });\n    }\n  }, {\n    key: 'onKeydownView',\n    value: function onKeydownView(e) {\n      var selectedKey = KEY_NUMBER[e.which];\n      var isMoveNode = selectedKey ? MOVE_DIRECTION[selectedKey] : null;\n\n      if (selectedKey === 'DELETE') {\n        this.deleteSelectedNode();\n      } else if (selectedKey === 'ENTER' || selectedKey === 'TAB') {\n        e.preventDefault();\n        var selectedNodes = this.getSelectedNodes();\n        var direction = selectedKey === 'TAB' ? APPEND_DIRECTION.RIGHT : APPEND_DIRECTION.BOTTOM;\n\n        if (selectedNodes === null || selectedNodes.length === 0) {\n          return;\n        }\n\n        var selectedNode = selectedNodes[0];\n        this.appendTempNode(selectedNode, direction);\n      } else if (isMoveNode) {\n        var isEditingNode = this.nodeList.filter(function (d) {\n          return d._isEdit;\n        }).length > 0;\n\n        if (!isEditingNode) {\n          this.moveSelectNode(MOVE_DIRECTION[selectedKey]);\n          e.preventDefault();\n        }\n      }\n    }\n  }, {\n    key: 'onClickAddNode',\n    value: function onClickAddNode(direction) {\n      var selectedNodes = this.getSelectedNodes();\n      if (selectedNodes === null || selectedNodes.length === 0) {\n        return;\n      }\n\n      var selectedNode = selectedNodes[0];\n      this.appendTempNode(selectedNode, direction);\n    }\n  }, {\n    key: 'createNodeData',\n    value: function createNodeData(nodeObj) {\n      return d3.hierarchy(nodeObj, function (d) {\n        return d.children;\n      });\n    }\n  }, {\n    key: 'initNodeData',\n    value: function initNodeData(jsonData) {\n      this.nodes = this.createNodeData(jsonData);\n      this.nodeList = this.nodes.descendants();\n      this.nodeList = this.nodeList.map(function (d) {\n        d._isShow = true;\n        d._isEdit = false;\n        d._isDragging = false;\n        return d;\n      });\n    }\n  }, {\n    key: 'updateNodesLayout',\n    value: function updateNodesLayout() {\n      var _this4 = this;\n\n      var isInitialLayout = this.$svg.attr('width') === null;\n\n      //各子ノードに対して、親からのインデックス番号を保持する\n      /*\n      node.childIndex = 0\n       |- node.childIndex = 0\n       |- node.childIndex = 1\n       |- node.childIndex = 2\n          |- node.childIndex = 0\n          |- node.childIndex = 1\n      */\n      this.setChildProperties(this.nodes, 0, true);\n\n      // 各親ノードに対して、自分の子孫に存在する葉っぱの数を保持する。子→親の順番で保持する。\n      /*\n      node.leafLength = 3\n       |- node.leafLength = 0 -- leave\n       |- node.leafLength = 0 -- leave\n       |- node.leafLength = 2\n          |- node.leafLength = 0 -- leave\n          |- node.leafLength = 0 -- leave\n      */\n      this.nodes.leaves().map(function (node) {\n        _this4.setLeafLength(node);\n      });\n\n      this.nodeList.map(function (node) {\n        // ノード名が長い場合に３点リーダー表示用プロパティ（ellipsisName）を設定する\n        _this4.setNodeNameProperties(node);\n        //各ノードに対して、縦方向の位置情報（インデックス番号）を割り当てる。親→子の順番で割り当てる。\n        _this4.setVerticalIndex(node);\n      });\n\n      //各ノードのx,y座標を算出\n      this.nodeList.map(function (d) {\n        d._x = d.depth * _this4.columnWidth;\n        d._y = d._verticalIndex * _this4.rowHeight;\n      });\n\n      this.columnCount = d3.max(this.nodeList, function (d) {\n        return d.depth;\n      }) + 1;\n      this.rowCount = d3.max(this.nodeList, function (d) {\n        return d._verticalIndex;\n      }) + 1;\n\n      this.svgWidth = this.columnCount * this.columnWidth;\n      this.svgHeight = this.rowCount * this.rowHeight + MARGIN.CONTAINER.BOTTOM;\n\n      if (isInitialLayout) {\n        this.$svg.attr('width', this.svgWidth).attr('height', this.svgHeight);\n      } else {\n        this.$svg.transition().duration(DEFAULT_DURATION).attr('width', this.svgWidth).attr('height', this.svgHeight);\n      }\n\n      this.updateBackground();\n    }\n  }, {\n    key: 'calculateNodePathD',\n    value: function calculateNodePathD(d) {\n      if (!d || !d.parent) {\n        return;\n      }\n      var margin = MARGIN.NODE.LEFT;\n      var currentY = d._y;\n      var parentY = d.parent._y;\n      var diffY = currentY - parentY;\n      if (diffY === 0) {\n        return 'M0,0 h10';\n      } else {\n        return 'M0,' + -diffY + ' q' + margin / 2 + ',0,' + margin / 2 + ',5 v' + (diffY - 10) + ' q0,' + margin / 2 + ',' + margin / 2 + ',' + margin / 2;\n      }\n    }\n    /*\n    子ノードのレイアウト設定処理。全ての子ノードに対して再帰的に実行する。\n     @param node (Uo) ノード情報\n    @param childIndex (int) 親ノードを基準のした場合のノードの位置インデックス\n    @param isShow (Boolean) ノードを表示する場合はtrue、そうでない場合はfalse\n    */\n\n  }, {\n    key: 'setChildProperties',\n    value: function setChildProperties(node, childIndex, isShow) {\n      var children = this.getChildren(node);\n      node._childIndex = childIndex;\n      node._isShow = isShow;\n      node._isTemp = !!node.data._isTemp;\n\n      if (children && children.length > 0) {\n        node._childrenLength = children.length;\n\n        //親が閉じられている場合は全ての子ノードを非表示にする\n        if (node._isToggleOpen === false) {\n          isShow = false;\n        }\n\n        for (var i = 0, len = children.length; i < len; i++) {\n          this.setChildProperties(children[i], i, isShow);\n        }\n      } else {\n        node._childrenLength = 0;\n      }\n    }\n  }, {\n    key: 'setLeafLength',\n    value: function setLeafLength(node) {\n      if (!this.hasChildren(node)) {\n        node._leafLength = 0;\n      } else {\n        // 表示されているノードのみ葉っぱの個数に含める\n        var showChildren = node.children.filter(function (d) {\n          return d._isShow;\n        });\n        var leafLength = showChildren.length;\n\n        // 子ノードの葉っぱの数を自分の葉っぱの数に加える\n        showChildren.map(function (n) {\n          if (n._leafLength > 0) {\n            leafLength += n._leafLength - 1; //最初の子は親と同じy座標に位置するため-1する\n          }\n        });\n        node._leafLength = leafLength;\n      }\n      if (node.parent !== null) {\n        this.setLeafLength(node.parent);\n      }\n    }\n  }, {\n    key: 'setNodeNameProperties',\n    value: function setNodeNameProperties(node) {\n      //名前用text要素からサイズをキャッシュしておき、他要素のレイアウトの計算に使用する。\n      // let nameSize = this.measureTextSize( this.getLineBreakTexts( node ) );\n      var nameSize = new Util().measureTextSize(node.data.name, this.$svg);\n      node._nameWidth = nameSize.width;\n      node._nameHeight = nameSize.height;\n\n      //項目名が長い（２行以上表示される）場合に省略表示を行う\n      var strEachLine = this.splitStringEachLine(node.data.name);\n      node._ellipsisName = strEachLine[0];\n      node._isEllpsis = strEachLine.length > 1;\n      if (node._isEllpsis) {\n        node._ellipsisName += '...';\n      }\n    }\n  }, {\n    key: 'setVerticalIndex',\n    value: function setVerticalIndex(node) {\n      var verticalIndex = 0;\n\n      if (node.parent === undefined || node.parent === null) {\n        //ルートノードの場合は一番上に表示する\n        verticalIndex = 0;\n      } else if (node._childIndex === 0 || !node._isShow) {\n        //長男ノードの場合は親の隣に位置するため、縦方向の位置は同じ\n        verticalIndex = node.parent._verticalIndex;\n      } else if (node.parent.children !== null) {\n        //兄弟ノードの場合は自分の兄の縦方向の１つ下の位置\n        node.parent.children.map(function (brotherNode) {\n          if (brotherNode._childIndex === node._childIndex - 1) {\n            //兄弟ノードの縦位置と葉っぱノードの数の合計\n            verticalIndex = brotherNode._verticalIndex + Math.max(brotherNode._leafLength - 1, 0) + 1;\n          }\n        });\n      }\n      node._verticalIndex = verticalIndex;\n    }\n  }, {\n    key: 'updateBackground',\n    value: function updateBackground() {\n      var _this5 = this;\n\n      if (this.$background === undefined) {\n        this.$background = this.$svg.append('g').attr('class', 'tree-bg').on('click', function () {\n          _this5.blurNode();\n        });\n      }\n\n      var $rects = this.$background.selectAll('rect');\n      var currentRectCount = $rects.data().length;\n      var needRectCount = Math.ceil(this.svgWidth / this.columnWidth);\n\n      if (currentRectCount < needRectCount) {\n        // 不足分の背景を加える\n        for (var i = currentRectCount; i < needRectCount; i++) {\n          this.$background.append('rect').attr('data-index', i).attr('width', this.columnWidth).attr('height', this.svgHeight).attr('x', i * this.columnWidth).attr('y', 0);\n        }\n      } else if (currentRectCount > needRectCount) {\n        // 余分がある場合は削除する\n        $rects.each(function (d) {\n          var $rect = d3.select(this);\n          var index = $rect.attr('data-index');\n          if (index >= needRectCount) {\n            $rect.remove();\n          }\n        });\n      }\n\n      $rects.transition().duration(DEFAULT_DURATION).attr('width', this.columnWidth).attr('height', this.svgHeight);\n    }\n  }, {\n    key: 'initLayout',\n    value: function initLayout() {\n      this.$nodeWrap = this.$svg.append('g').attr('transform', 'translate(0, ' + MARGIN.CONTAINER.TOP + ')');\n    }\n  }, {\n    key: 'showTooltip',\n    value: function showTooltip($nodeName, nodeData) {\n      if (!nodeData._isEllpsis) {\n        return;\n      }\n\n      var tooltipMargin = {\n        left: 10,\n        top: 5\n      };\n\n      var $tooltip = this.$svgWrap.append('div').attr('class', 'node-tooltip');\n\n      var $tooltipText = $tooltip.append('p').attr('class', 'node-tooltip-text').text(nodeData.data.name);\n\n      var tooltipHeight = $tooltip.node().clientHeight;\n      var tooltipTop = nodeData._y + MARGIN.CONTAINER.TOP - this.rowHeight / 2 - tooltipHeight - tooltipMargin.top;\n\n      $tooltip.attr('style', 'left:' + (nodeData._x + tooltipMargin.left) + 'px; top:' + tooltipTop + 'px;');\n    }\n  }, {\n    key: 'hideTooltip',\n    value: function hideTooltip() {\n      var $tooltip = this.$svgWrap.selectAll('.node-tooltip').remove();\n    }\n  }, {\n    key: 'updateUserInputNode',\n    value: function updateUserInputNode(node) {\n      var _this6 = this;\n\n      var _this = this;\n      var maxLeafCount = void 0;\n      var minLeafCount = void 0;\n\n      this.nodes.each(function (d) {\n        maxLeafCount = d.data.maximum_leaf_count || -1, minLeafCount = d.data.minimum_leaf_count || -1;\n\n        if (maxLeafCount < 0 || minLeafCount < 0) {\n          return true;\n        }\n\n        var inputNodeData = _this.createNodeData({\n          id: _this6.createNodeId(),\n          name: '回答者が入力',\n          children: null\n        });\n        // 回答者入力ノードフラグ\n        inputNodeData._isUserInput = true;\n        _this6.insertChild(d, inputNodeData, 0);\n      });\n\n      this.nodeList = this.nodes.descendants();\n    }\n    // ノードのドラッグ移動開始\n\n  }, {\n    key: 'startDragging',\n    value: function startDragging(target) {\n      this.$dragNode = d3.select(target);\n      var dragNodeData = this.$dragNode.data()[0];\n      this.setPropertyForNode(dragNodeData, '_isDragging', true);\n      this.focusNode(dragNodeData);\n    }\n    // ノードのドラッグ中処理\n\n  }, {\n    key: 'doDragging',\n    value: function doDragging() {\n      var dragNodeData = this.$dragNode.data()[0];\n      if (dragNodeData.depth === 0 || dragNodeData._isUserInput) {\n        return;\n      }\n\n      if (!this.$svgWrap.classed('is-dragging')) {\n        this.appendDragLayer();\n      }\n      if (this.$dummyNode) {\n        this.$dummyNode.attr('transform', 'translate(' + d3.event.x + ', ' + d3.event.y + ')');\n      } else {\n        this.createDummyNode();\n      }\n    }\n  }, {\n    key: 'createDummyNode',\n    value: function createDummyNode() {\n      this.$dummyNode = new Util().copySelection(this.$dragNode, this.$nodeWrap).attr('class', 'node--drag').attr('opacity', '0.5')\n      // dragAreaのmouseoverを検知できるようにdummyNodeのマウスイベントを無効化\n      .attr('pointer-events', 'none');\n\n      this.$dummyNode.attr('data-init-transform', this.$dummyNode.attr('transform'));\n    }\n  }, {\n    key: 'appendDragLayer',\n    value: function appendDragLayer() {\n      var _this = this;\n      var dragNodeData = this.$dragNode.data()[0];\n\n      var overDragArea = function overDragArea(d) {\n        d3.select(this).classed('is-selected', true);\n      };\n      var outDragArea = function outDragArea(d) {\n        d3.select(this).classed('is-selected', false);\n      };\n      var setDragAreaProperties = function setDragAreaProperties($dragArea) {\n        $dragArea.attr('class', 'tree-dragarea').classed('is-disabled', function (d) {\n          // ノードは兄弟ノード間のみ移動できるようにする\n          var $target = d3.select(this);\n          var layoutIndex = parseInt($target.attr('data-childindex'));\n          var isBrothers = d.parent === dragNodeData.parent;\n          var isYoungBrother = isBrothers && dragNodeData._childIndex === layoutIndex - 1;\n          var isSamePosition = isYoungBrother || d._isDragging;\n          // let isDisabled = !isBrothers || isSamePosition || d._isUserInput;\n          var isDisabled = isSamePosition || d._isUserInput;\n\n          return isDisabled;\n        }).attr('width', _this.columnWidth).attr('data-depth', function (d) {\n          return d.depth;\n        }).attr('data-parentid', function (d) {\n          return d.parent ? d.parent.data.id : -1;\n        }).on('mouseover', overDragArea).on('mouseout', outDragArea);\n      };\n      var appendChildren = function appendChildren($dragArea, isLast) {\n        $dragArea.append('rect').attr('width', _this.columnWidth).attr('height', function (d) {\n          return getLayerHeight(d, isLast);\n        });\n        $dragArea.append('line').attr('x1', 0).attr('y1', function (d) {\n          return getLineY(d, isLast);\n        }).attr('x2', $dragArea.attr('width')).attr('y2', function (d) {\n          return getLineY(d, isLast);\n        });\n      };\n      var getLayerHeight = function getLayerHeight(d, isLast) {\n        var dragAreaHeight = 0;\n        var isFirst = d._childIndex === 0;\n        var isTop = d._verticalIndex === 0;\n\n        if (isFirst) {\n          dragAreaHeight = _this.rowHeight / 2;\n          // if( !isTop ) {\n          //   // ノードより上をドラッグ可能領域とする\n          //   dragAreaHeight += _this.svgHeight - ( _this.svgHeight - d._y );\n          // }\n        } else if (isLast) {\n          // ノードより下の領域をドラック可能領域とする\n          dragAreaHeight = _this.svgHeight - d._y - _this.rowHeight / 2;\n        } else {\n          // ノード間をドラッグ可能領域とする\n          var brotherNode = _this.getChildren(d.parent)[d._childIndex - 1];\n          dragAreaHeight = d._y - brotherNode._y;\n        }\n        return dragAreaHeight;\n      };\n      var getLineY = function getLineY(d, isLast) {\n        var isFirst = d._childIndex === 0;\n        var lineY = 0;\n\n        if (isFirst && isLast) {\n          lineY = _this.rowHeight / 2;\n        } else if (isFirst) {\n          // lineY = d._y;\n          lineY = 0;\n        } else if (isLast) {\n          lineY = _this.rowHeight / 2;\n        } else {\n          lineY = getLayerHeight(d, isLast) - _this.rowHeight / 2;\n        }\n        return lineY;\n      };\n\n      var $dragArea = this.$nodeWrap.selectAll('.node').append('g').classed('is-first', function (d) {\n        return d._childIndex === 0;\n      }).attr('transform', function (d) {\n        return 'translate(0, ' + -getLayerHeight(d) + ')';\n      }).attr('data-childindex', function (d) {\n        return d._childIndex;\n      }).call(setDragAreaProperties).call(function ($dragArea) {\n        appendChildren($dragArea, false);\n      });\n\n      var $lastdragArea = this.$nodeWrap.selectAll('.node--youngest').append('g').classed('is-last', true).attr('transform', 'translate(0,0)').attr('data-childindex', function (d) {\n        return d._childIndex + 1;\n      }).call(setDragAreaProperties).call(function ($dragArea) {\n        appendChildren($dragArea, true);\n      });\n\n      $dragArea = this.$nodeWrap.selectAll('.tree-dragarea');\n      this.$svgWrap.classed('is-dragging', true);\n    }\n    // ノードのドラッグ移動終了\n\n  }, {\n    key: 'endDragging',\n    value: function endDragging() {\n      var _this7 = this;\n\n      var $selectedDragArea = d3.select('.tree-dragarea.is-selected');\n      var exitFunc = function exitFunc() {\n        var dragNodeData = _this7.$dragNode.data()[0];\n\n        _this7.$nodeWrap.selectAll('.tree-dragarea').remove();\n        _this7.$svgWrap.classed('is-dragging', false);\n        _this7.setPropertyForNode(dragNodeData, '_isDragging', false);\n\n        _this7.$dummyNode = null;\n        _this7.$svg.selectAll('.node--drag').remove();\n        _this7.$dragNode = null;\n      };\n\n      if (this.$dummyNode === undefined || this.$dummyNode === null) {\n        exitFunc();\n        return;\n      }\n\n      if ($selectedDragArea.data().length > 0) {\n        var moveNode = this.$dragNode.data()[0];\n        var toParentId = parseInt($selectedDragArea.attr('data-parentid'));\n        var toChildIndex = parseInt($selectedDragArea.attr('data-childindex'));\n        var toDepth = parseInt($selectedDragArea.attr('data-depth'));\n        var isMovedNode = this.isMovedNode(moveNode, toParentId, toChildIndex, toDepth);\n\n        if (isMovedNode) {\n          // ノードの移動を実行して処理を終了する\n          this.updateNode({\n            type: NODE_METHOD.MOVE_NODE,\n            data: {\n              moveNode: this.$dragNode.data()[0],\n              toParentId: toParentId,\n              toChildIndex: toChildIndex,\n              toDepth: toDepth\n            }\n          });\n          exitFunc();\n          return;\n        }\n      }\n      // 移動しない場合はダミーノードを元の位置に戻し、削除する\n      this.$dummyNode.transition().duration(DEFAULT_DURATION).attr('transform', this.$dummyNode.attr('data-init-transform')).on('end', function () {\n        exitFunc();\n      });\n    }\n    // 項目名の改行を行なった結果をHTML要素に変換して返す\n\n  }, {\n    key: 'getLineBreakTexts',\n    value: function getLineBreakTexts(node) {\n      var lineHeight = 1.5;\n      var textHtml = '';\n      var strEachLine = this.splitStringEachLine(node.data.name);\n\n      strEachLine.forEach(function (text, index) {\n        textHtml += '<tspan class=\"line line' + index + '\" x=\"0\" y=\"' + index * lineHeight + 'em\" dx=\"0.6em\" dy=\"0.35em\">' + text + '</tspan>';\n      });\n      return textHtml;\n    }\n    // ノード名複数行対応：行ごとの文字列に分割した配列を作成する\n\n  }, {\n    key: 'splitStringEachLine',\n    value: function splitStringEachLine(str) {\n      var strEachLine = [];\n      var lineCount = 0;\n      var strLength = void 0;\n\n      for (var i = 0, len = str.length; i < len; i++) {\n        var chara = str[i];\n        if (strEachLine.length <= lineCount) {\n          strEachLine.push('');\n        }\n        strEachLine[lineCount] += chara;\n\n        // 1行内の文字数が一定数より多い場合は改行の可能性がある（一定数＝全角文字で１行に必ず入る文字数）\n        var isPossibilityLineBreak = strEachLine[lineCount].length > this.textMinLength;\n        if (isPossibilityLineBreak) {\n          // 文字幅が１行に表示できる文字を超えている場合は改行\n          var strSize = new Util().measureTextSize(strEachLine[lineCount], this.$svg);\n          if (strSize.width >= this.textLineWidth) {\n            ++lineCount;\n          }\n        }\n      }\n      return strEachLine;\n    }\n  }, {\n    key: 'initNode',\n    value: function initNode() {\n      this.$nodes = this.createNode(this.nodeList);\n      this.updateParentNode();\n    }\n  }, {\n    key: 'updateParentNode',\n    value: function updateParentNode() {\n      this.updateLineToChild();\n      this.updateToggleChildren();\n    }\n    // 親ノードが子を持っているか確認する\n\n  }, {\n    key: 'hasChildren',\n    value: function hasChildren(node) {\n      var children = this.getChildren(node);\n      return children && children.length > 0;\n    }\n    // 親ノードの子を取得する\n\n  }, {\n    key: 'getChildren',\n    value: function getChildren(node) {\n      return node.children;\n    }\n    // 親ノードの子に指定されたノードを挿入する\n\n  }, {\n    key: 'insertChild',\n    value: function insertChild(parentNode, insertNode, childIndex) {\n\n      if (this.hasChildren(parentNode)) {\n        var children = this.getChildren(parentNode);\n\n        if (childIndex === undefined || children.length <= childIndex) {\n          children.push(insertNode);\n          parentNode.data.children.push(insertNode.data);\n        } else {\n          children.splice(childIndex, 0, insertNode);\n          parentNode.data.children.splice(childIndex, 0, insertNode.data);\n        }\n      } else {\n        parentNode.children = [insertNode];\n        parentNode.data.children = [insertNode];\n      }\n      insertNode.parent = parentNode;\n      this.setPropertyForNode(insertNode, 'depth', parentNode.depth + 1, function (val) {\n        return val + 1;\n      });\n    }\n    /*\n    ノードの子孫も含めて任意のプロパティを更新する\n    @param node (Object) 更新の対象となるノードデータ\n    @param propertyName (String) プロパティ名\n    @param value (anything) 値\n    @param recursive (function) 子孫へ再起的に実行する際にvalueに対して何かしら処理を行う際に使用する\n    */\n\n  }, {\n    key: 'setPropertyForNode',\n    value: function setPropertyForNode(node, propertyName, value, recursive) {\n      node[propertyName] = value;\n\n      if (!this.hasChildren(node)) {\n        return;\n      }\n      var children = this.getChildren(node);\n\n      if (typeof recursive === 'function') {\n        value = recursive(value);\n      }\n\n      for (var i = 0, len = children.length; i < len; i++) {\n        this.setPropertyForNode(children[i], propertyName, value, recursive);\n      }\n    }\n    /*\n    ノード作成・更新時に共通のプロパティを設定する処理\n    */\n\n  }, {\n    key: 'setCommonPropetiesForNode',\n    value: function setCommonPropetiesForNode($nodes) {\n      var _this8 = this;\n\n      $nodes.classed('node--oldest', function (d) {\n        return d._childIndex === 0;\n      }).classed('node--youngest', function (d) {\n        return d.parent && d._childIndex === _this8.getChildren(d.parent).length - 1;\n      }).classed('node--branch', function (d) {\n        var children = [];\n        // let leafs = [];\n\n        if (_this8.hasChildren(d)) {\n          children = _this8.getChildren(d);\n          // leafs = children.filter((d) => {\n          //   return !this.hasChildren(d);\n          // });\n        }\n        return children.length > 0;\n      }).classed('node--leaf', function (d) {\n        return !_this8.hasChildren(d);\n      }).classed('node--other', function (d) {\n        // 子は存在するが、葉を１つも持っていないノード\n        var hasChildren = _this8.getChildren(d);\n        var hasLeaf = false;\n        if (_this8.hasChildren(d)) {\n          _this8.getChildren(d).map(function (d) {\n            if (!_this8.hasChildren(d)) {\n              hasLeaf = true;\n              return false;\n            }\n          });\n        }\n        return hasChildren && !hasLeaf;\n      }).classed('node--userinput', function (d) {\n        return d._isUserInput;\n      }).classed('is-close', false);\n    }\n    // ノードを追加する際に新しいIDを作成する\n\n  }, {\n    key: 'createNodeId',\n    value: function createNodeId() {\n      var maxId = d3.max(this.nodes.descendants(), function (d) {\n        return d.data.id;\n      });\n      return ++maxId;\n    }\n    // ノード作成処理\n\n  }, {\n    key: 'createNode',\n    value: function createNode(dataSet) {\n      var _this9 = this;\n\n      var _this = this;\n\n      var $nodes = this.$nodeWrap.selectAll('.node').data(dataSet, function (d) {\n        return d.data.id;\n      }).enter().append('g').attr('class', function (d) {\n        return 'node';\n      }).call(this.setCommonPropetiesForNode.bind(this)).attr('width', this.columnWidth).attr('height', this.nodeHeight).attr('opacity', 1).attr('transform', function (d) {\n        return 'translate(' + d._x + ', ' + d._y + ')';\n      });\n\n      //背景に敷くためのrect要素を先に要素追加しておき、後でプロパティを設定する\n      var $nodesBg = $nodes.append('rect');\n\n      //ノード名の左側に表示するアイコン\n      // let $nodeHead = $nodes.append('circle')\n      //   .attr('r', 3);\n\n      //ノード名用text要素\n      var $nodeText = $nodes.append('text').attr('class', 'node-name').attr('x', MARGIN.NODE_NAME.LEFT).attr('y', '0.35em').text(function (d) {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n      // 親ノードと子ノードを繋ぐためのパス\n      var $nodePath = $nodes.append('path').attr('class', 'node-path').attr('d', this.calculateNodePathD).attr('stroke', '#666').attr('fill', 'none');\n\n      //背景用rect要素のプロパティを設定\n      //ノードドラッグ時に発生させたくないイベントはこのSelectionにバインドする\n      $nodesBg.attr('height', function (d) {\n        return d._nameHeight;\n      }).attr('class', 'node-bg').attr('width', this.columnWidth - MARGIN.NODE.LEFT).attr('height', this.nodeHeight).attr('x', MARGIN.NODE.LEFT).attr('y', -(this.nodeHeight / 2)).attr('fill', 'transparent').on('mouseover', function (d) {\n        if (_this.$svgWrap.classed('is-dragging')) {\n          return;\n        }\n        _this.showTooltip(d3.select(this), d);\n      }).on('mouseout', function (d) {\n        _this9.hideTooltip();\n      }).on('click', function (d) {\n        _this.focusNode(d);\n      }).on('dblclick', function (d) {\n        _this.editStartNodeName(d);\n      });\n\n      $nodes.each(function (d) {\n        if (!d._isUserInput) {\n          //回答者入力欄以外はドラッグ＆ドロップで移動可能にする\n          d3.select(this).call(d3.drag().on('start', function () {\n            _this.startDragging(this);\n          }).on('drag', function () {\n            _this.doDragging();\n          }).on('end', function () {\n            _this.endDragging();\n          }));\n        } else {\n          //回答者入力ノード用ラベル\n          d3.select(this).append('text').attr('class', 'node--userinput-range').attr('x', _this.columnWidth - 10).attr('y', '0.35em').attr('text-anchor', 'end').text(function (d) {\n            var maxLeafCount = d.parent.data.maximum_leaf_count;\n            var minLeafCount = d.parent.data.minimum_leaf_count;\n            return minLeafCount + '\\u301C' + maxLeafCount;\n          });\n        };\n      });\n\n      return $nodes;\n    }\n    // ノード更新処理\n\n  }, {\n    key: 'updateNode',\n    value: function updateNode(param) {\n      var _this10 = this;\n\n      var _this = this;\n\n      if (param) {\n        switch (param.type) {\n          case NODE_METHOD.UPDATE_NAME:\n            // 指定されたパラメータを元に内部データを更新する\n            this.nodeList.map(function (node) {\n              if (param.data.id !== node.data.id) return true;\n              for (var key in param.data) {\n                node.data[key] = param.data[key];\n              }\n              _this10.setNodeNameProperties(node);\n            });\n            break;\n          case NODE_METHOD.TOGGLE_CHILDREN:\n            var node = param.data.node;\n            if (node._isToggleOpen === undefined) {\n              node._isToggleOpen = false;\n            } else {\n              node._isToggleOpen = !node._isToggleOpen;\n            }\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.DELETE_NODE:\n            //ルートノードは削除できない\n            if (param.data.deleteNode.depth === 0) {\n              return;\n            }\n\n            // 対象ノードをデータから削除し、各ノードの位置を再計算する。\n            this.deleteNodeData(param.data.deleteNode, param.confirm);\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.APPEND_NODE_TEMP:\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n          case NODE_METHOD.MOVE_NODE:\n            var data = param.data;\n            var moveNode = data.moveNode,\n                toParentId = data.toParentId,\n                toChildIndex = data.toChildIndex,\n                toDepth = data.toDepth;\n\n            var isSameParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n            var isYounger = moveNode._childIndex < toChildIndex;\n\n            if (isSameParent && isYounger) {\n              --toChildIndex;\n            }\n\n            if (!this.isMovedNode(moveNode, toParentId, toChildIndex, toDepth)) {\n              return;\n            }\n\n            //ノードリストから対象のノードを取り除く\n            this.deleteNodeData(moveNode);\n\n            //対象ノードを移動先の位置に加える\n            this.nodes.each(function (d) {\n              if (d.data.id !== toParentId) {\n                return true;\n              }\n              _this10.insertChild(d, moveNode, toChildIndex);\n              return false;\n            });\n\n            this.nodeList = this.nodes.descendants();\n            this.updateNodesLayout();\n            break;\n        }\n      }\n\n      var $newNode = this.createNode(this.nodeList);\n\n      // 内部データを元に各ノードの状態を更新する\n      this.$nodes = this.$nodeWrap.selectAll('.node').data(this.nodeList, function (d) {\n        // idをもとに変更前と変更後のノード情報を紐づける\n        return d.data.id;\n      }).call(this.setCommonPropetiesForNode.bind(this)).transition().on('end', function (d) {\n        // アニメーションが終わった後にノードを非表示にする\n        if (!d._isShow) {\n          d3.select(this).classed('is-close', true);\n        }\n      }).duration(DEFAULT_DURATION).attr('opacity', function (d) {\n        return d._isShow ? 1 : 0;\n      }).attr('transform', function (d) {\n        return 'translate(' + d._x + ', ' + d._y + ')';\n      });\n\n      var $delNodes = this.$nodeWrap.selectAll('.node').data(this.nodeList, function (d) {\n        return d.data.id;\n      }).exit().remove();\n\n      var $texts = this.$nodes.selectAll('.node-name').text(function (d) {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n      this.$nodeWrap.selectAll('.node-path').transition().duration(DEFAULT_DURATION).attr('d', this.calculateNodePathD);\n\n      if ($newNode !== undefined && $newNode !== null && $newNode.data().length > 0) {\n        //内部データを更新した後、追加されたノードは編集状態にする\n        var newNodeData = $newNode.data()[0];\n        this.editStartNodeName(newNodeData);\n        this.focusNode(newNodeData);\n      }\n\n      this.updateParentNode();\n    }\n  }, {\n    key: 'focusNode',\n    value: function focusNode(selectNodes) {\n      var selectIds = [];\n\n      if (Array.isArray(selectNodes)) {\n        selectNodes.map(function (d) {\n          selectIds.push(d.data.id);\n        });\n      } else {\n        selectIds.push(selectNodes.data.id);\n      }\n\n      this.$nodes.each(function (d) {\n        var $node = d3.select(this);\n        var isSelected = selectIds.indexOf(d.data.id) > -1;\n        $node.classed('is-selected', isSelected);\n      });\n    }\n  }, {\n    key: 'blurNode',\n    value: function blurNode() {\n      this.$nodes.each(function (d) {\n        d3.select(this).classed('is-selected', false);\n      });\n    }\n  }, {\n    key: 'moveSelectNode',\n    value: function moveSelectNode(move_direction) {\n      var selectedNodes = this.getSelectedNodes();\n      if (selectedNodes === null || selectedNodes.length === 0) {\n        return;\n      }\n      var selectedNode = selectedNodes[0];\n      var _childIndex = selectedNode._childIndex,\n          depth = selectedNode.depth;\n\n      var newSelectNodes = void 0;\n      var cousinNodes = void 0;\n\n      switch (move_direction) {\n        case MOVE_DIRECTION.TOP:\n          cousinNodes = this.nodeList.filter(function (d) {\n            return selectedNode.depth === d.depth && selectedNode._verticalIndex > d._verticalIndex;\n          });\n          newSelectNodes = cousinNodes.length > 0 ? cousinNodes[cousinNodes.length - 1] : undefined;\n          break;\n        case MOVE_DIRECTION.LEFT:\n          newSelectNodes = selectedNode.parent ? [selectedNode.parent] : undefined;\n          break;\n        case MOVE_DIRECTION.BOTTOM:\n          cousinNodes = this.nodeList.filter(function (d) {\n            return selectedNode.depth === d.depth && selectedNode._verticalIndex < d._verticalIndex;\n          });\n          newSelectNodes = cousinNodes.length > 0 ? cousinNodes[0] : undefined;\n          break;\n        case MOVE_DIRECTION.RIGHT:\n          newSelectNodes = this.nodeList.filter(function (d) {\n            return selectedNode === d.parent && d._childIndex === 0 && d.depth === depth + 1;\n          });\n          break;\n      }\n\n      if (newSelectNodes === undefined || newSelectNodes.length === 0) {\n        return;\n      }\n\n      this.focusNode(newSelectNodes);\n    }\n  }, {\n    key: 'getSelectedNodes',\n    value: function getSelectedNodes() {\n      var selectedNodes = this.$nodeWrap.select('.node.is-selected').data();\n      if (selectedNodes === undefined && selectedData.length === 0) {\n        return null;\n      }\n      return selectedNodes;\n    }\n  }, {\n    key: 'deleteSelectedNode',\n    value: function deleteSelectedNode() {\n      var selectedNodes = this.getSelectedNodes();\n\n      for (var i = 0, len = selectedNodes.length; i < len; i++) {\n        this.deleteNode(selectedNodes[i]);\n      }\n    }\n    // ツリーに表示されているノードを削除する\n\n  }, {\n    key: 'deleteNode',\n    value: function deleteNode(node) {\n      var _this11 = this;\n\n      //編集中には削除処理を実行しない\n      if (node._isEdit) {\n        return;\n      }\n\n      this.updateNode({\n        type: NODE_METHOD.DELETE_NODE,\n        data: {\n          deleteNode: node\n        },\n        confirm: function (_confirm) {\n          function confirm(_x) {\n            return _confirm.apply(this, arguments);\n          }\n\n          confirm.toString = function () {\n            return _confirm.toString();\n          };\n\n          return confirm;\n        }(function (deleteNode) {\n          // 確認処理を行い、キャンセルした場合は処理を中断する。\n          var hasChildren = _this11.getChildren(deleteNode) && _this11.getChildren(deleteNode).length > 0;\n          var doDelete = true;\n\n          if (hasChildren) {\n            doDelete = confirm('子階層のノードも削除されますが、本当に削除してもよろしいですか？');\n          }\n          return doDelete;\n        })\n      });\n    }\n    // 内部ノード情報から対象のノードを削除する\n\n  }, {\n    key: 'deleteNodeData',\n    value: function deleteNodeData(node, confirmFunction) {\n      var deleteNode = null;\n      var parentNode = null;\n\n      this.nodes.each(function (d) {\n        if (node === d) {\n          deleteNode = d;\n          parentNode = d.parent;\n          return false;\n        }\n      });\n\n      // 確認処理を行い、キャンセルした場合は処理を中断する。\n      var doConfirm = confirmFunction && typeof confirmFunction === 'function';\n      if (doConfirm && !confirmFunction(deleteNode)) {\n        return;\n      }\n\n      parentNode.children.map(function (d, i) {\n        if (d !== deleteNode) {\n          return true;\n        }\n        parentNode.children.splice(i, 1);\n      });\n    }\n  }, {\n    key: 'editStartNodeName',\n    value: function editStartNodeName(node) {\n      var _this = this;\n      var $node = void 0;\n\n      if (node._isUserInput) {\n        return;\n      }\n\n      this.$nodes.each(function (d) {\n        if (d.data.id === node.data.id) {\n          $node = d3.select(this);\n          return false;\n        }\n      });\n\n      node._isEdit = true;\n      $node.classed('is-editing', true);\n\n      //テキストボックスを生成し、編集状態にする\n      var $inputNode = this.$svgWrap.append('input').attr('type', 'text').attr('value', node.data.name).attr('class', 'node-textbox').attr('style', 'left:' + (node._x + MARGIN.NODE.LEFT) + 'px; top:' + (node._y + MARGIN.CONTAINER.TOP - this.nodeHeight / 2) + 'px; width:' + (this.columnWidth - MARGIN.NODE.LEFT) + 'px; height:' + this.nodeHeight + 'px;').on('blur', function () {\n        var isEmpty = this.value.trim() === '';\n        var newNodeName = d3.select(this).node().value;\n\n        //テキストボックスからフォーカスが外れた場合は元のラベルを更新する\n        node._isEdit = false;\n        $node.classed('is-editing', false);\n        _this.$svgWrap.selectAll('.node-textbox').remove();\n\n        if (isEmpty) {\n          if (node._isTemp) {\n            //ノード追加時の場合は追加前の状態に戻す\n            _this.deleteNode(node);\n            return;\n          } else {\n            //空文字の場合は元の名前に戻す\n            newNodeName = node.data.name;\n          }\n        }\n\n        _this.updateNode({\n          type: NODE_METHOD.UPDATE_NAME,\n          data: {\n            id: node.data.id,\n            name: newNodeName\n          }\n        });\n      });\n\n      $inputNode.node().focus();\n    }\n  }, {\n    key: 'editEndNodeName',\n    value: function editEndNodeName() {\n      var $inputNode = this.$svgWrap.selectAll('.node-textbox');\n      if ($inputNode.data().length === 0) {\n        return;\n      }\n      $inputNode.node().blur();\n\n      this.updateLineToChild();\n    }\n  }, {\n    key: 'isMovedNode',\n    value: function isMovedNode(moveNode, toParentId, toChildIndex, toDepth) {\n      var someParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n      var someChildIndex = moveNode._childIndex === toChildIndex;\n      var someDepth = moveNode.depth === toDepth;\n      return !(someParent && someChildIndex && someDepth);\n    }\n  }, {\n    key: 'isNodeNameEmpty',\n    value: function isNodeNameEmpty() {\n      var isEmpty = true;\n      var $inputNode = this.$svgWrap.selectAll('.node-textbox');\n      if ($inputNode.data().length === 0) {\n        return isEmpty;\n      }\n      isEmpty = $inputNode.node().value.trim() === '';\n      return isEmpty;\n    }\n  }, {\n    key: 'appendTempNode',\n    value: function appendTempNode(selectedNode, direction) {\n\n      if (selectedNode._isEdit) {\n        if (!this.isNodeNameEmpty()) {\n          this.editEndNodeName();\n        }\n        return;\n      } else if (selectedNode._isUserInput && direction === APPEND_DIRECTION.RIGHT) {\n        return;\n      }\n\n      var parentNode = selectedNode.parent;\n      if (parentNode === null && direction === APPEND_DIRECTION.BOTTOM) {\n        //ルート階層の下にノードは追加できないようにする\n        return;\n      }\n\n      // ノード追加を行うための一時ノードを生成してツリーに加える\n      var tempNodeData = this.createNodeData({\n        id: this.createNodeId(),\n        name: '',\n        children: null,\n        _isTemp: true\n      });\n\n      switch (direction) {\n        case APPEND_DIRECTION.RIGHT:\n          this.insertChild(selectedNode, tempNodeData);\n          break;\n        case APPEND_DIRECTION.BOTTOM:\n          this.insertChild(parentNode, tempNodeData, selectedNode._childIndex + 1);\n          break;\n      }\n\n      this.updateNode({\n        type: NODE_METHOD.APPEND_NODE_TEMP\n      });\n    }\n  }, {\n    key: 'updateToggleChildren',\n    value: function updateToggleChildren() {\n      var _this = this;\n      var circleRadius = 8;\n\n      this.$nodes.each(function (d) {\n        var $node = d3.select(this);\n        var isParent = _this.hasChildren(d);\n        var hasToggle = $node.select('.node-toggle').node() !== null;\n\n        if (isParent && !hasToggle) {\n          var $toggle = $node.append('g').attr('class', 'node-toggle').attr('transform', 'translate(' + (_this.columnWidth - circleRadius * 2) + ', 0)').on('click', function (d) {\n            _this.toggleChildren(d);\n          });\n\n          var $circles = $toggle.append('circle').attr('r', circleRadius);\n\n          var $texts = $toggle.append('text').attr('class', 'node-toggle-label').attr('width', circleRadius * 2).attr('hegith', circleRadius * 2).attr('text-anchor', 'middle').attr('dy', circleRadius / 2).text(d._isToggleOpen === false ? '+' : '–');\n        } else if (isParent && hasToggle) {\n          $node.select('.node-toggle-label').text(d._isToggleOpen === false ? '+' : '–');\n        } else if (!isParent && hasToggle) {\n          $node.select('.node-toggle').remove();\n        }\n      });\n    }\n  }, {\n    key: 'updateLineToChild',\n    value: function updateLineToChild() {\n      var _this = this;\n\n      this.$svgWrap.selectAll('.node-branch-line').remove();\n      this.$svgWrap.selectAll('.node--other').each(function (d) {\n        var $node = d3.select(this);\n        var isParent = _this.hasChildren(d);\n        var hasLine = $node.select('.node-branch-line').node() !== null;\n\n        // if( isParent && !hasLine && !d._isEllpsis ) {\n        //   $node.append('line')\n        //     .attr('class', 'node-branch-line')\n        //     .attr('stroke', 'black')\n        //     .attr('stroke-width', 1)\n        //     .attr('stroke-dasharray', '1 4')\n        //     .attr('x1', d._nameWidth + MARGIN.NODE_NAME.LEFT + 10)\n        //     .attr('y1', 0)\n        //     .attr('x2', _this.columnWidth - 10)\n        //     .attr('y2', 0);\n        // }\n      });\n    }\n  }, {\n    key: 'toggleChildren',\n    value: function toggleChildren(parentData) {\n      this.updateNode({\n        type: NODE_METHOD.TOGGLE_CHILDREN,\n        data: {\n          node: parentData\n        }\n      });\n    }\n  }]);\n\n  return DirectoryTree;\n}();\n\nvar Util = function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, [{\n    key: 'measureTextSize',\n    value: function measureTextSize(str, $container) {\n      var $text = $container.append('text').attr('class', 'temp-measure-text').html(str);\n      var bbox = $text.node().getBBox();\n      $text.remove();\n      return bbox;\n    }\n  }, {\n    key: 'copySelection',\n    value: function copySelection($target, $to) {\n      var node = $target.node();\n      var nodeName = node.nodeName,\n          attributes = node.attributes,\n          children = node.children;\n\n      var $copy = $to.append(nodeName);\n\n      Object.keys(attributes).forEach(function (key) {\n        $copy.attr(attributes[key].name, attributes[key].value);\n      });\n      $copy.html($target.html());\n\n      return $copy;\n    }\n  }]);\n\n  return Util;\n}();\n\n(function () {\n  new DirectoryTree('#tree', '.tree-wrap').init();\n})();\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e0a24043a405f5043d70","const MARGIN = {\n  CONTAINER: {\n    TOP: 30,\n    BOTTOM: 50\n  },\n  NODE: {\n    LEFT: 10\n  },\n  NODE_NAME: {\n    LEFT: 20\n  }\n};\nconst DEFAULT_DURATION = 500;\n\n// ノード名の１行あたりの最大文字数（半角）\nconst NODE_NAME_LINE_MAX = 26;\n\n// ノード更新時のメソッド識別用\nconst NODE_METHOD = {\n  UPDATE_NAME: 'updateName',\n  TOGGLE_CHILDREN: 'toggleChildren',\n  DELETE_NODE: 'deleteNode',\n  APPEND_NODE_TEMP: 'appendNodeTemp',\n  MOVE_NODE: 'moveNode'\n};\n\nconst KEY_NUMBER = {\n  8: 'DELETE',\n  9: 'TAB',\n  13: 'ENTER',\n  37: 'LEFT',\n  38: 'TOP',\n  40: 'BOTTOM',\n  39: 'RIGHT'\n};\n\n// ノード追加時の位置\nconst APPEND_DIRECTION = {\n  BOTTOM: 'appendToBottom',\n  RIGHT: 'appendToRight'\n};\n\n// ノード移動時の位置\nconst MOVE_DIRECTION = {\n  TOP: 'moveTop',\n  LEFT: 'moveLeft',\n  BOTTOM: 'moveBottom',\n  RIGHT: 'moveRight'\n};\n\nclass DirectoryTree {\n  constructor(root, wrapper) {\n    this.$svgWrap = d3.select(wrapper);\n    this.$svg = d3.select(root);\n    this.$addNodeBottom = d3.select('.js-tree-addnode-bottom');\n    this.$addNodeRight = d3.select('.js-tree-addnode-right');\n\n    this.columnWidth = 200;\n    this.textLineWidth = this.columnWidth - 50;\n    this.textMinLength = 10;\n    this.rowHeight = 35;\n    this.nodeHeight = 30;\n  }\n  init() {\n    this.getJsonData((data) => {\n      this.bindEvents();\n      this.initNodeData(data);\n      this.updateUserInputNode();\n      this.updateNodesLayout();\n      this.initLayout();\n      this.initNode();\n    });\n  }\n  getJsonData(callback) {\n    d3.json('./data/sample-data.json', (error, data) => {\n      if (error) throw error;\n      callback(data);\n    });\n  }\n  bindEvents() {\n    document.addEventListener('keydown', (e) => {\n      this.onKeydownView(e);\n    });\n    this.$addNodeBottom.on('click', (e) => {\n      this.onClickAddNode( APPEND_DIRECTION.BOTTOM );\n    });\n    this.$addNodeRight.on('click', (e) => {\n      this.onClickAddNode( APPEND_DIRECTION.RIGHT );\n    });\n  }\n  onKeydownView(e) {\n    let selectedKey = KEY_NUMBER[e.which];\n    let isMoveNode = selectedKey ? MOVE_DIRECTION[selectedKey] : null;\n\n    if( selectedKey === 'DELETE' ) {\n      this.deleteSelectedNode();\n    }\n    else if( selectedKey === 'ENTER' || selectedKey === 'TAB' ) {\n      e.preventDefault();\n      let selectedNodes = this.getSelectedNodes();\n      let direction = selectedKey === 'TAB' ? APPEND_DIRECTION.RIGHT : APPEND_DIRECTION.BOTTOM;\n\n      if( selectedNodes === null || selectedNodes.length === 0 ) {\n        return;\n      }\n\n      let selectedNode = selectedNodes[0];\n      this.appendTempNode( selectedNode, direction );\n    }\n    else if( isMoveNode ) {\n      let isEditingNode = this.nodeList.filter((d) => {\n        return d._isEdit;\n      }).length > 0;\n\n      if( !isEditingNode ) {\n        this.moveSelectNode( MOVE_DIRECTION[selectedKey] );\n        e.preventDefault();\n      }\n    }\n  }\n  onClickAddNode(direction) {\n    let selectedNodes = this.getSelectedNodes();\n    if( selectedNodes === null || selectedNodes.length === 0 ) {\n      return;\n    }\n\n    let selectedNode = selectedNodes[0];\n    this.appendTempNode( selectedNode, direction );\n  }\n  createNodeData( nodeObj ) {\n    return d3.hierarchy( nodeObj, (d) => {\n      return d.children;\n    });\n  }\n  initNodeData( jsonData ) {\n    this.nodes = this.createNodeData( jsonData );\n    this.nodeList = this.nodes.descendants();\n    this.nodeList = this.nodeList.map((d) => {\n      d._isShow = true;\n      d._isEdit = false;\n      d._isDragging = false;\n      return d;\n    });\n  }\n  updateNodesLayout() {\n    let isInitialLayout = this.$svg.attr('width') === null;\n\n    //各子ノードに対して、親からのインデックス番号を保持する\n    /*\n    node.childIndex = 0\n     |- node.childIndex = 0\n     |- node.childIndex = 1\n     |- node.childIndex = 2\n        |- node.childIndex = 0\n        |- node.childIndex = 1\n    */\n    this.setChildProperties( this.nodes, 0, true );\n\n    // 各親ノードに対して、自分の子孫に存在する葉っぱの数を保持する。子→親の順番で保持する。\n    /*\n    node.leafLength = 3\n     |- node.leafLength = 0 -- leave\n     |- node.leafLength = 0 -- leave\n     |- node.leafLength = 2\n        |- node.leafLength = 0 -- leave\n        |- node.leafLength = 0 -- leave\n    */\n    this.nodes.leaves().map((node) => {\n      this.setLeafLength( node );\n    });\n\n    this.nodeList.map((node) => {\n      // ノード名が長い場合に３点リーダー表示用プロパティ（ellipsisName）を設定する\n      this.setNodeNameProperties(node);\n      //各ノードに対して、縦方向の位置情報（インデックス番号）を割り当てる。親→子の順番で割り当てる。\n      this.setVerticalIndex(node);\n    });\n\n    //各ノードのx,y座標を算出\n    this.nodeList.map((d) => {\n      d._x = d.depth * this.columnWidth;\n      d._y = d._verticalIndex * this.rowHeight;\n    });\n\n    this.columnCount = d3.max( this.nodeList, (d) => {\n      return d.depth;\n    }) + 1;\n    this.rowCount = d3.max( this.nodeList, (d) => {\n      return d._verticalIndex;\n    }) + 1;\n\n    this.svgWidth = this.columnCount * this.columnWidth;\n    this.svgHeight = this.rowCount * this.rowHeight + MARGIN.CONTAINER.BOTTOM;\n\n    if( isInitialLayout ) {\n      this.$svg\n        .attr('width', this.svgWidth )\n        .attr('height', this.svgHeight );\n    }else {\n      this.$svg\n        .transition()\n        .duration(DEFAULT_DURATION)\n        .attr('width', this.svgWidth )\n        .attr('height', this.svgHeight );\n    }\n\n    this.updateBackground();\n  }\n  calculateNodePathD (d) {\n    if (!d || !d.parent) {\n      return\n    }\n    let margin = MARGIN.NODE.LEFT\n    let currentY = d._y\n    let parentY = d.parent._y\n    let diffY = currentY - parentY\n    if (diffY === 0) {\n      return 'M0,0 h10'\n    } else {\n      return `M0,${-(diffY)} q${margin/2},0,${margin/2},5 v${diffY-10} q0,${margin/2},${margin/2},${margin/2}`\n    }\n  }\n  /*\n  子ノードのレイアウト設定処理。全ての子ノードに対して再帰的に実行する。\n\n  @param node (Uo) ノード情報\n  @param childIndex (int) 親ノードを基準のした場合のノードの位置インデックス\n  @param isShow (Boolean) ノードを表示する場合はtrue、そうでない場合はfalse\n  */\n  setChildProperties(node, childIndex, isShow) {\n    let children = this.getChildren(node);\n    node._childIndex = childIndex;\n    node._isShow = isShow;\n    node._isTemp = !!node.data._isTemp;\n\n    if( children && children.length > 0 ) {\n      node._childrenLength = children.length;\n\n      //親が閉じられている場合は全ての子ノードを非表示にする\n      if( node._isToggleOpen === false ) {\n        isShow = false;\n      }\n\n      for( let i = 0, len = children.length; i < len; i++ ) {\n        this.setChildProperties( children[i], i, isShow );\n      }\n    }else {\n      node._childrenLength = 0;\n    }\n  }\n  setLeafLength(node) {\n    if( !this.hasChildren(node) ) {\n      node._leafLength = 0;\n    }else {\n      // 表示されているノードのみ葉っぱの個数に含める\n      let showChildren = node.children.filter((d) => {\n        return d._isShow;\n      });\n      let leafLength = showChildren.length;\n\n      // 子ノードの葉っぱの数を自分の葉っぱの数に加える\n      showChildren.map((n) => {\n        if( n._leafLength > 0 ) {\n          leafLength += n._leafLength - 1; //最初の子は親と同じy座標に位置するため-1する\n        }\n      });\n      node._leafLength = leafLength;\n    }\n    if( node.parent !== null ) {\n      this.setLeafLength( node.parent );\n    }\n  }\n  setNodeNameProperties(node) {\n    //名前用text要素からサイズをキャッシュしておき、他要素のレイアウトの計算に使用する。\n    // let nameSize = this.measureTextSize( this.getLineBreakTexts( node ) );\n    let nameSize = new Util().measureTextSize( node.data.name, this.$svg );\n    node._nameWidth = nameSize.width;\n    node._nameHeight = nameSize.height;\n    \n    //項目名が長い（２行以上表示される）場合に省略表示を行う\n    let strEachLine = this.splitStringEachLine( node.data.name );\n    node._ellipsisName = strEachLine[0];\n    node._isEllpsis = strEachLine.length > 1;\n    if( node._isEllpsis ) {\n      node._ellipsisName += '...';\n    }\n  }\n  setVerticalIndex(node) {\n    let verticalIndex = 0;\n\n    if( node.parent === undefined || node.parent === null ) {\n      //ルートノードの場合は一番上に表示する\n      verticalIndex = 0;\n    }\n    else if( node._childIndex === 0 || !node._isShow ) {\n      //長男ノードの場合は親の隣に位置するため、縦方向の位置は同じ\n      verticalIndex = node.parent._verticalIndex;\n    }\n    else if( node.parent.children !== null ) {\n      //兄弟ノードの場合は自分の兄の縦方向の１つ下の位置\n      node.parent.children.map((brotherNode) => {\n        if(brotherNode._childIndex === node._childIndex - 1) {\n          //兄弟ノードの縦位置と葉っぱノードの数の合計\n          verticalIndex = brotherNode._verticalIndex + Math.max(brotherNode._leafLength - 1, 0) + 1;\n        }\n      });\n    }\n    node._verticalIndex = verticalIndex;\n  }\n  updateBackground() {\n    if( this.$background === undefined ) {\n      this.$background = this.$svg.append('g')\n        .attr('class', 'tree-bg')\n        .on('click', () => {\n          this.blurNode();\n        });\n    }\n\n    let $rects = this.$background.selectAll('rect');\n    let currentRectCount = $rects.data().length;\n    let needRectCount = Math.ceil(this.svgWidth / this.columnWidth);\n\n    if( currentRectCount < needRectCount ) {\n      // 不足分の背景を加える\n      for( let i = currentRectCount; i < needRectCount; i++ ) {\n        this.$background.append('rect')\n          .attr('data-index', i)\n          .attr('width', this.columnWidth)\n          .attr('height', this.svgHeight)\n          .attr('x', i * this.columnWidth)\n          .attr('y', 0);\n      }\n    }else if( currentRectCount > needRectCount ) {\n      // 余分がある場合は削除する\n      $rects.each(function(d) {\n        let $rect = d3.select(this);\n        let index = $rect.attr('data-index');\n        if( index >= needRectCount ) {\n          $rect.remove();\n        }\n      });\n    }\n\n    $rects\n      .transition()\n      .duration(DEFAULT_DURATION)\n      .attr('width', this.columnWidth)\n      .attr('height', this.svgHeight);\n  }\n  initLayout() {\n    this.$nodeWrap = this.$svg.append('g')\n      .attr('transform', 'translate(0, ' + MARGIN.CONTAINER.TOP + ')');\n  }\n  showTooltip($nodeName, nodeData) {\n    if( !nodeData._isEllpsis ) {\n      return;\n    }\n\n    let tooltipMargin = {\n      left: 10,\n      top: 5\n    };\n\n    let $tooltip = this.$svgWrap\n      .append('div')\n      .attr('class', 'node-tooltip');\n\n    let $tooltipText = $tooltip\n      .append('p')\n      .attr('class', 'node-tooltip-text')\n      .text(nodeData.data.name);\n\n    let tooltipHeight = $tooltip.node().clientHeight;\n    let tooltipTop = nodeData._y + MARGIN.CONTAINER.TOP - this.rowHeight / 2 - tooltipHeight - tooltipMargin.top;\n\n    $tooltip\n      .attr('style', `left:${nodeData._x + tooltipMargin.left}px; top:${tooltipTop}px;`);\n  }\n  hideTooltip() {\n    let $tooltip = this.$svgWrap.selectAll('.node-tooltip').remove();\n  }\n  updateUserInputNode(node) {\n    let _this = this;\n    let maxLeafCount;\n    let minLeafCount;\n\n    this.nodes.each((d) => {\n      maxLeafCount = d.data.maximum_leaf_count || -1,\n      minLeafCount = d.data.minimum_leaf_count || -1;\n\n      if( maxLeafCount < 0 || minLeafCount < 0 ) {\n        return true;\n      }\n\n      let inputNodeData = _this.createNodeData({\n        id: this.createNodeId(),\n        name: '回答者が入力',\n        children: null\n      });\n      // 回答者入力ノードフラグ\n      inputNodeData._isUserInput = true;\n      this.insertChild( d, inputNodeData, 0 );\n    });\n\n    this.nodeList = this.nodes.descendants();\n  }\n  // ノードのドラッグ移動開始\n  startDragging(target) {\n    this.$dragNode = d3.select(target);\n    let dragNodeData = this.$dragNode.data()[0];\n    this.setPropertyForNode( dragNodeData, '_isDragging', true );\n    this.focusNode(dragNodeData);\n  }\n  // ノードのドラッグ中処理\n  doDragging() {\n    let dragNodeData = this.$dragNode.data()[0];\n    if( dragNodeData.depth === 0 || dragNodeData._isUserInput ) {\n      return;\n    }\n\n    if( !this.$svgWrap.classed('is-dragging') ) {\n      this.appendDragLayer();\n    }\n    if( this.$dummyNode ) {\n      this.$dummyNode.attr('transform', `translate(${d3.event.x}, ${d3.event.y})`);\n    }else {\n      this.createDummyNode();\n    }\n  }\n  createDummyNode() {\n    this.$dummyNode = new Util().copySelection( this.$dragNode, this.$nodeWrap )\n      .attr('class', 'node--drag')\n      .attr('opacity', '0.5')\n      // dragAreaのmouseoverを検知できるようにdummyNodeのマウスイベントを無効化\n      .attr('pointer-events', 'none');\n\n    this.$dummyNode\n      .attr('data-init-transform', this.$dummyNode.attr('transform'));\n  }\n  appendDragLayer() {\n    let _this = this;\n    let dragNodeData = this.$dragNode.data()[0];\n\n    let overDragArea = function(d) {\n      d3.select(this).classed('is-selected', true);\n    };\n    let outDragArea = function(d) {\n      d3.select(this).classed('is-selected', false)\n    };\n    let setDragAreaProperties = function($dragArea) {\n      $dragArea\n        .attr('class', 'tree-dragarea')\n        .classed('is-disabled', function(d) {\n          // ノードは兄弟ノード間のみ移動できるようにする\n          let $target = d3.select(this);\n          let layoutIndex = parseInt($target.attr('data-childindex'));\n          let isBrothers = d.parent === dragNodeData.parent;\n          let isYoungBrother = isBrothers && dragNodeData._childIndex === layoutIndex - 1;\n          let isSamePosition = isYoungBrother || d._isDragging;\n          // let isDisabled = !isBrothers || isSamePosition || d._isUserInput;\n          let isDisabled = isSamePosition || d._isUserInput;\n\n          return isDisabled;\n        })\n        .attr('width', _this.columnWidth)\n        .attr('data-depth', (d) => {\n          return d.depth;\n        })\n        .attr('data-parentid', (d) => {\n          return d.parent ? d.parent.data.id : -1;\n        })\n        .on('mouseover', overDragArea)\n        .on('mouseout', outDragArea);\n    };\n    let appendChildren = function( $dragArea, isLast ) {\n      $dragArea.append('rect')\n        .attr('width', _this.columnWidth)\n        .attr('height', (d) => {\n          return getLayerHeight(d, isLast);\n        });\n      $dragArea.append('line')\n        .attr('x1', 0)\n        .attr('y1', (d) => {\n          return getLineY(d, isLast);\n        })\n        .attr('x2', $dragArea.attr('width'))\n        .attr('y2', (d) => {\n          return getLineY(d, isLast);\n        });\n    };\n    let getLayerHeight = function(d, isLast) {\n      let dragAreaHeight = 0;\n      let isFirst = d._childIndex === 0;\n      let isTop = d._verticalIndex === 0;\n\n      if(isFirst) {\n        dragAreaHeight = _this.rowHeight / 2;\n        // if( !isTop ) {\n        //   // ノードより上をドラッグ可能領域とする\n        //   dragAreaHeight += _this.svgHeight - ( _this.svgHeight - d._y );\n        // }\n      }\n      else if(isLast) {\n        // ノードより下の領域をドラック可能領域とする\n        dragAreaHeight = _this.svgHeight - d._y - (_this.rowHeight / 2);\n      }\n      else {\n        // ノード間をドラッグ可能領域とする\n        let brotherNode = _this.getChildren(d.parent)[d._childIndex - 1];\n        dragAreaHeight = d._y - brotherNode._y;\n      }\n      return dragAreaHeight;\n    };\n    let getLineY = function(d, isLast) {\n      let isFirst = d._childIndex === 0;\n      let lineY = 0;\n\n      if( isFirst && isLast ) {\n        lineY = _this.rowHeight / 2;\n      }\n      else if( isFirst ) {\n        // lineY = d._y;\n        lineY = 0;\n      }\n      else if( isLast ) {\n        lineY = _this.rowHeight / 2;\n      }\n      else {\n        lineY = getLayerHeight(d, isLast) - _this.rowHeight / 2;\n      }\n      return lineY;\n    }\n\n    let $dragArea = this.$nodeWrap.selectAll('.node')\n      .append('g')\n      .classed('is-first', (d) => {\n        return d._childIndex === 0;\n      })\n      .attr('transform', (d) => {\n        return `translate(0, ${ -(getLayerHeight(d)) })`;\n      })\n      .attr('data-childindex', (d) => {\n        return d._childIndex;\n      })\n      .call( setDragAreaProperties )\n      .call(($dragArea) => {\n        appendChildren( $dragArea, false );\n      });\n\n    let $lastdragArea = this.$nodeWrap.selectAll('.node--youngest')\n      .append('g')\n      .classed('is-last', true)\n      .attr('transform', 'translate(0,0)')\n      .attr('data-childindex', (d) => {\n        return d._childIndex + 1;\n      })\n      .call( setDragAreaProperties )\n      .call(($dragArea) => {\n        appendChildren( $dragArea, true );\n      });\n\n    $dragArea = this.$nodeWrap.selectAll('.tree-dragarea');\n    this.$svgWrap.classed('is-dragging', true);\n  }\n  // ノードのドラッグ移動終了\n  endDragging() {\n    let $selectedDragArea = d3.select('.tree-dragarea.is-selected');\n    let exitFunc = () => {\n      let dragNodeData = this.$dragNode.data()[0];\n\n      this.$nodeWrap.selectAll('.tree-dragarea').remove();\n      this.$svgWrap.classed('is-dragging', false);\n      this.setPropertyForNode( dragNodeData, '_isDragging', false );\n\n      this.$dummyNode = null;\n      this.$svg.selectAll('.node--drag').remove();\n      this.$dragNode = null;\n    };\n\n    if( this.$dummyNode === undefined || this.$dummyNode === null ) {\n      exitFunc();\n      return;\n    }\n\n    if( $selectedDragArea.data().length > 0 ) {\n      let moveNode = this.$dragNode.data()[0]; \n      let toParentId = parseInt($selectedDragArea.attr('data-parentid'));\n      let toChildIndex = parseInt($selectedDragArea.attr('data-childindex'));\n      let toDepth = parseInt($selectedDragArea.attr('data-depth'));\n      let isMovedNode = this.isMovedNode( moveNode, toParentId, toChildIndex, toDepth );\n\n      if( isMovedNode ) {\n        // ノードの移動を実行して処理を終了する\n        this.updateNode({\n          type: NODE_METHOD.MOVE_NODE,\n          data: {\n            moveNode: this.$dragNode.data()[0],\n            toParentId: toParentId,\n            toChildIndex: toChildIndex,\n            toDepth: toDepth\n          }\n        });\n        exitFunc();\n        return;\n      }\n    }\n    // 移動しない場合はダミーノードを元の位置に戻し、削除する\n    this.$dummyNode\n      .transition()\n      .duration( DEFAULT_DURATION )\n      .attr( 'transform', this.$dummyNode.attr('data-init-transform') )\n      .on('end', () => {\n        exitFunc();\n      });\n  }\n  // 項目名の改行を行なった結果をHTML要素に変換して返す\n  getLineBreakTexts(node) {\n    let lineHeight = 1.5;\n    let textHtml = '';\n    let strEachLine = this.splitStringEachLine( node.data.name );\n\n    strEachLine.forEach((text, index) => {\n      textHtml += '<tspan class=\"line line' + index + '\" x=\"0\" y=\"' + (index * lineHeight) + 'em\" dx=\"0.6em\" dy=\"0.35em\">' + text + '</tspan>'\n    });\n    return textHtml;\n  }\n  // ノード名複数行対応：行ごとの文字列に分割した配列を作成する\n  splitStringEachLine(str) {\n    let strEachLine = [];\n    let lineCount = 0;\n    let strLength\n\n    for( let i = 0, len = str.length; i < len; i++ ) {\n      let chara = str[i];\n      if( strEachLine.length <= lineCount ) {\n        strEachLine.push('');\n      }\n      strEachLine[lineCount] += chara;\n\n      // 1行内の文字数が一定数より多い場合は改行の可能性がある（一定数＝全角文字で１行に必ず入る文字数）\n      let isPossibilityLineBreak = strEachLine[lineCount].length > this.textMinLength;\n      if( isPossibilityLineBreak ) {\n        // 文字幅が１行に表示できる文字を超えている場合は改行\n        let strSize = new Util().measureTextSize( strEachLine[lineCount], this.$svg );\n        if( strSize.width >= this.textLineWidth ) {\n          ++lineCount;\n        }\n      }\n    }\n    return strEachLine;\n  }\n  initNode() {\n    this.$nodes = this.createNode( this.nodeList );\n    this.updateParentNode();\n  }\n  updateParentNode() {\n    this.updateLineToChild();\n    this.updateToggleChildren();\n  }\n  // 親ノードが子を持っているか確認する\n  hasChildren(node) {\n    let children = this.getChildren(node);\n    return children && children.length > 0;\n  }\n  // 親ノードの子を取得する\n  getChildren(node) {\n    return node.children;\n  }\n  // 親ノードの子に指定されたノードを挿入する\n  insertChild(parentNode, insertNode, childIndex) {\n\n    if( this.hasChildren( parentNode ) ) {\n      let children = this.getChildren( parentNode );\n\n      if( childIndex === undefined || children.length <= childIndex ) {\n        children.push( insertNode );\n        parentNode.data.children.push( insertNode.data );\n      }else {\n        children.splice( childIndex, 0, insertNode );\n        parentNode.data.children.splice( childIndex, 0, insertNode.data );\n      }\n    }\n    else {\n      parentNode.children = [insertNode];\n      parentNode.data.children = [insertNode];\n    }\n    insertNode.parent = parentNode;\n    this.setPropertyForNode( insertNode, 'depth', parentNode.depth + 1, (val) => {\n      return val + 1;\n    });\n  }\n  /*\n  ノードの子孫も含めて任意のプロパティを更新する\n  @param node (Object) 更新の対象となるノードデータ\n  @param propertyName (String) プロパティ名\n  @param value (anything) 値\n  @param recursive (function) 子孫へ再起的に実行する際にvalueに対して何かしら処理を行う際に使用する\n  */\n  setPropertyForNode(node, propertyName, value, recursive) {\n    node[propertyName] = value;\n\n    if( !this.hasChildren( node ) ) {\n      return;\n    }\n    let children = this.getChildren( node );\n\n    if( typeof recursive === 'function' ) {\n      value = recursive(value);\n    }\n\n    for( let i = 0, len = children.length; i < len; i++ ) {\n      this.setPropertyForNode( children[i], propertyName, value, recursive );\n    }\n  }\n  /*\n  ノード作成・更新時に共通のプロパティを設定する処理\n  */\n  setCommonPropetiesForNode($nodes) {\n    $nodes\n      .classed('node--oldest', (d) => {\n        return d._childIndex === 0;\n      })\n      .classed('node--youngest', (d) => {\n        return d.parent && d._childIndex === this.getChildren(d.parent).length - 1;\n      })\n      .classed('node--branch', (d) => {\n        let children = [];\n        // let leafs = [];\n\n        if( this.hasChildren(d) ) {\n          children = this.getChildren(d);\n          // leafs = children.filter((d) => {\n          //   return !this.hasChildren(d);\n          // });\n        }\n        return children.length > 0;\n      })\n      .classed('node--leaf', (d) => {\n        return !this.hasChildren(d);\n      })\n      .classed('node--other', (d) => {\n        // 子は存在するが、葉を１つも持っていないノード\n        let hasChildren = this.getChildren(d);\n        let hasLeaf = false;\n        if( this.hasChildren(d) ) {\n          this.getChildren(d).map((d) => {\n            if( !this.hasChildren(d) ) {\n              hasLeaf = true;\n              return false;\n            } \n          });\n        }\n        return hasChildren && !hasLeaf;\n      })\n      .classed('node--userinput', (d) => {\n        return d._isUserInput;\n      })\n      .classed('is-close', false)\n  }\n  // ノードを追加する際に新しいIDを作成する\n  createNodeId() {\n    let maxId = d3.max( this.nodes.descendants(), (d) => {\n      return d.data.id;\n    });\n    return ++maxId;\n  }\n  // ノード作成処理\n  createNode(dataSet) {\n    let _this = this;\n\n    let $nodes = this.$nodeWrap.selectAll('.node')\n      .data( dataSet, (d) => {\n        return d.data.id;\n      })\n      .enter()\n      .append('g')\n      .attr('class', (d) => {\n        return 'node';\n      })\n      .call( this.setCommonPropetiesForNode.bind(this) )\n      .attr('width', this.columnWidth)\n      .attr('height', this.nodeHeight)\n      .attr('opacity', 1)\n      .attr('transform', function(d) {\n        return 'translate(' + (d._x) + ', ' + (d._y) + ')';\n      });\n\n    //背景に敷くためのrect要素を先に要素追加しておき、後でプロパティを設定する\n    let $nodesBg = $nodes.append('rect');\n\n    //ノード名の左側に表示するアイコン\n    // let $nodeHead = $nodes.append('circle')\n    //   .attr('r', 3);\n\n    //ノード名用text要素\n    let $nodeText = $nodes.append('text')\n      .attr('class', 'node-name')\n      .attr('x', MARGIN.NODE_NAME.LEFT)\n      .attr('y', '0.35em')\n      .text((d) => {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n    // 親ノードと子ノードを繋ぐためのパス\n    let $nodePath = $nodes.append('path')\n      .attr('class', 'node-path')\n      .attr('d', this.calculateNodePathD)\n      .attr('stroke', '#666')\n      .attr('fill', 'none');\n\n    //背景用rect要素のプロパティを設定\n    //ノードドラッグ時に発生させたくないイベントはこのSelectionにバインドする\n    $nodesBg.attr('height', (d) => {\n      return d._nameHeight;\n    })\n    .attr('class', 'node-bg')\n    .attr('width', this.columnWidth - MARGIN.NODE.LEFT)\n    .attr('height', this.nodeHeight)\n    .attr('x', MARGIN.NODE.LEFT)\n    .attr('y', -(this.nodeHeight / 2) )\n    .attr('fill', 'transparent')\n    .on('mouseover', function(d) {\n      if( _this.$svgWrap.classed('is-dragging') ) {\n        return;\n      }\n      _this.showTooltip(d3.select(this), d);\n    })\n    .on('mouseout', (d) => {\n      this.hideTooltip();\n    })\n    .on('click', (d) => {\n      _this.focusNode(d);\n    })\n    .on('dblclick', (d) => {\n      _this.editStartNodeName( d );\n    });\n\n    $nodes.each(function(d) {\n      if( !d._isUserInput ) {\n        //回答者入力欄以外はドラッグ＆ドロップで移動可能にする\n        d3.select(this)\n          .call(\n            d3.drag()\n            .on('start', function() {\n              _this.startDragging(this);\n            })\n            .on('drag', () => {\n              _this.doDragging();\n            })\n            .on('end', () => {\n              _this.endDragging();\n            })\n          );\n      }else {\n        //回答者入力ノード用ラベル\n        d3.select(this)\n          .append('text')\n          .attr('class', 'node--userinput-range')\n          .attr('x', _this.columnWidth - 10)\n          .attr('y', '0.35em')\n          .attr('text-anchor', 'end')\n          .text((d) => {\n            let maxLeafCount = d.parent.data.maximum_leaf_count;\n            let minLeafCount = d.parent.data.minimum_leaf_count;\n            return `${minLeafCount}〜${maxLeafCount}`;\n          })\n        };\n    });\n\n    return $nodes;\n  }\n  // ノード更新処理\n  updateNode( param ) {\n    var _this = this;\n\n    if( param ) {\n      switch( param.type ) {\n        case NODE_METHOD.UPDATE_NAME:\n          // 指定されたパラメータを元に内部データを更新する\n          this.nodeList.map( (node) => {\n            if( param.data.id !== node.data.id ) return true;\n            for( let key in param.data ) {\n              node.data[key] = param.data[key];\n            }\n            this.setNodeNameProperties(node);\n          });\n          break;\n        case NODE_METHOD.TOGGLE_CHILDREN:\n          const node = param.data.node\n          if( node._isToggleOpen === undefined ) {\n            node._isToggleOpen = false;\n          }else {\n            node._isToggleOpen = !node._isToggleOpen;\n          }\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.DELETE_NODE:\n          //ルートノードは削除できない\n          if( param.data.deleteNode.depth === 0 ) {\n            return;\n          }\n\n          // 対象ノードをデータから削除し、各ノードの位置を再計算する。\n          this.deleteNodeData( param.data.deleteNode, param.confirm );\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.APPEND_NODE_TEMP:\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n        case NODE_METHOD.MOVE_NODE:\n          let {data} = param;\n          let {moveNode, toParentId, toChildIndex, toDepth} = data;\n          let isSameParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n          let isYounger = moveNode._childIndex < toChildIndex;\n\n          if( isSameParent && isYounger ) {\n            --toChildIndex;\n          }\n\n          if( !this.isMovedNode( moveNode, toParentId, toChildIndex, toDepth ) ) {\n            return;\n          }\n\n          //ノードリストから対象のノードを取り除く\n          this.deleteNodeData( moveNode );\n\n          //対象ノードを移動先の位置に加える\n          this.nodes.each((d) => {\n            if( d.data.id !== toParentId ) {\n              return true;\n            }\n            this.insertChild( d, moveNode, toChildIndex );\n            return false;\n          });\n\n          this.nodeList = this.nodes.descendants();\n          this.updateNodesLayout();\n          break;\n      }\n    }\n\n    let $newNode = this.createNode( this.nodeList );\n\n    // 内部データを元に各ノードの状態を更新する\n    this.$nodes = this.$nodeWrap.selectAll('.node')\n      .data( this.nodeList, (d) => {\n        // idをもとに変更前と変更後のノード情報を紐づける\n        return d.data.id;\n      })\n      .call( this.setCommonPropetiesForNode.bind(this) )\n      .transition()\n      .on('end', function(d) {\n        // アニメーションが終わった後にノードを非表示にする\n        if( !d._isShow ) {\n          d3.select(this).classed('is-close', true);\n        }\n      })\n      .duration(DEFAULT_DURATION)\n      .attr('opacity', (d) => {\n        return d._isShow ? 1 : 0;\n      })\n      .attr('transform', (d) => {\n        return `translate(${d._x}, ${d._y})`;\n      });\n    \n    let $delNodes = this.$nodeWrap.selectAll('.node')\n      .data( this.nodeList, (d) => {\n        return d.data.id;\n      })\n      .exit()\n      .remove();\n\n    let $texts = this.$nodes.selectAll('.node-name')\n      .text((d) => {\n        return d._ellipsisName ? d._ellipsisName : d.data.name;\n      });\n\n    this.$nodeWrap.selectAll('.node-path')\n      .transition()\n      .duration(DEFAULT_DURATION)\n      .attr('d', this.calculateNodePathD);\n\n    if( $newNode !== undefined && $newNode !== null && $newNode.data().length > 0 ) {\n      //内部データを更新した後、追加されたノードは編集状態にする\n      let newNodeData = $newNode.data()[0];\n      this.editStartNodeName( newNodeData );\n      this.focusNode(newNodeData);\n    }\n\n    this.updateParentNode();\n  }\n  focusNode( selectNodes ) {\n    let selectIds = [];\n\n    if( Array.isArray( selectNodes ) ) {\n      selectNodes.map((d) => {\n        selectIds.push( d.data.id );\n      });\n    }else {\n      selectIds.push( selectNodes.data.id );\n    }\n\n    this.$nodes.each(function(d) {\n      let $node = d3.select(this);\n      let isSelected = selectIds.indexOf(d.data.id) > -1;\n      $node.classed('is-selected', isSelected);\n    });\n  }\n  blurNode() {\n    this.$nodes.each(function(d) {\n      d3.select(this).classed('is-selected', false);\n    });\n  }\n  moveSelectNode(move_direction) {\n    let selectedNodes = this.getSelectedNodes();\n    if( selectedNodes === null || selectedNodes.length === 0 ) {\n      return;\n    }\n    let selectedNode = selectedNodes[0];\n    let {_childIndex, depth} = selectedNode;\n    let newSelectNodes;\n    let cousinNodes;\n\n    switch( move_direction ) {\n      case MOVE_DIRECTION.TOP:\n        cousinNodes = this.nodeList.filter((d) => {\n          return selectedNode.depth === d.depth && selectedNode._verticalIndex > d._verticalIndex;\n        });\n        newSelectNodes = cousinNodes.length > 0 ? cousinNodes[ cousinNodes.length - 1 ] : undefined;\n        break;\n      case MOVE_DIRECTION.LEFT:\n        newSelectNodes = selectedNode.parent ? [selectedNode.parent] : undefined;\n        break;\n      case MOVE_DIRECTION.BOTTOM:\n        cousinNodes = this.nodeList.filter((d) => {\n          return selectedNode.depth === d.depth && selectedNode._verticalIndex < d._verticalIndex;\n        });\n        newSelectNodes = cousinNodes.length > 0 ? cousinNodes[0] : undefined;\n        break;\n      case MOVE_DIRECTION.RIGHT:\n        newSelectNodes = this.nodeList.filter((d) => {\n          return selectedNode === d.parent && d._childIndex === 0 && d.depth === depth + 1;\n        });\n        break;\n    }\n\n    if( newSelectNodes === undefined || newSelectNodes.length === 0 ) {\n      return;\n    }\n\n    this.focusNode(newSelectNodes);\n  }\n  getSelectedNodes() {\n    let selectedNodes = this.$nodeWrap.select('.node.is-selected').data();\n    if( selectedNodes === undefined && selectedData.length === 0 ) {\n      return null;\n    }\n    return selectedNodes;\n  }\n  deleteSelectedNode() {\n    let selectedNodes = this.getSelectedNodes();\n\n    for( let i = 0, len = selectedNodes.length; i < len; i++ ) {\n      this.deleteNode( selectedNodes[i] );\n    }\n  }\n  // ツリーに表示されているノードを削除する\n  deleteNode(node) {\n    //編集中には削除処理を実行しない\n    if( node._isEdit ) {\n      return;\n    }\n\n    this.updateNode({\n      type: NODE_METHOD.DELETE_NODE,\n      data: {\n        deleteNode: node\n      },\n      confirm: (deleteNode) => {\n        // 確認処理を行い、キャンセルした場合は処理を中断する。\n        let hasChildren = this.getChildren(deleteNode) && this.getChildren(deleteNode).length > 0;\n        let doDelete = true;\n\n        if( hasChildren ) {\n          doDelete = confirm('子階層のノードも削除されますが、本当に削除してもよろしいですか？');\n        }\n        return doDelete;\n      }\n    });\n  }\n  // 内部ノード情報から対象のノードを削除する\n  deleteNodeData(node, confirmFunction) {\n    let deleteNode = null;\n    let parentNode = null;\n\n    this.nodes.each((d) => {\n      if( node === d ) {\n        deleteNode = d;\n        parentNode = d.parent;\n        return false;\n      }\n    });\n\n    // 確認処理を行い、キャンセルした場合は処理を中断する。\n    let doConfirm = confirmFunction && typeof confirmFunction === 'function';\n    if( doConfirm && !confirmFunction(deleteNode) ) {\n      return;\n    }\n\n    parentNode.children.map((d, i) => {\n      if( d !== deleteNode ) {\n        return true;\n      }\n      parentNode.children.splice(i, 1);\n    });\n  }\n  editStartNodeName( node ) {\n    let _this = this;\n    let $node;\n\n    if( node._isUserInput ) {\n      return;\n    }\n\n    this.$nodes.each(function(d) {\n      if( d.data.id === node.data.id ) {\n        $node = d3.select(this);\n        return false;\n      }\n    });\n\n    node._isEdit = true;\n    $node.classed('is-editing', true);\n\n    //テキストボックスを生成し、編集状態にする\n    let $inputNode = this.$svgWrap.append('input')\n      .attr('type', 'text')\n      .attr('value', node.data.name)\n      .attr('class', 'node-textbox')\n      .attr('style', `left:${node._x + MARGIN.NODE.LEFT}px; top:${node._y + MARGIN.CONTAINER.TOP - this.nodeHeight / 2}px; width:${this.columnWidth - MARGIN.NODE.LEFT}px; height:${this.nodeHeight}px;`)\n      .on('blur', function() {\n        let isEmpty = this.value.trim() === '';\n        let newNodeName = d3.select(this).node().value;\n\n        //テキストボックスからフォーカスが外れた場合は元のラベルを更新する\n        node._isEdit = false;\n        $node.classed('is-editing', false);\n        _this.$svgWrap.selectAll('.node-textbox').remove();\n\n        if( isEmpty ) {\n          if( node._isTemp ) {\n            //ノード追加時の場合は追加前の状態に戻す\n            _this.deleteNode( node );\n            return;\n          }else {\n            //空文字の場合は元の名前に戻す\n            newNodeName = node.data.name;\n          }\n        }\n\n        _this.updateNode({\n          type: NODE_METHOD.UPDATE_NAME,\n          data: {\n            id: node.data.id,\n            name: newNodeName\n          }\n        });\n      });\n\n    $inputNode.node().focus();\n  }\n  editEndNodeName() {\n    let $inputNode = this.$svgWrap.selectAll('.node-textbox');\n    if( $inputNode.data().length === 0 ) {\n      return;\n    }\n    $inputNode.node().blur();\n\n    this.updateLineToChild();\n  }\n  isMovedNode(moveNode, toParentId, toChildIndex, toDepth) {\n    let someParent = moveNode.parent && moveNode.parent.data.id === toParentId;\n    let someChildIndex = moveNode._childIndex === toChildIndex;\n    let someDepth = moveNode.depth === toDepth;\n    return !(someParent && someChildIndex && someDepth);\n  }\n  isNodeNameEmpty() {\n    let isEmpty = true;\n    let $inputNode = this.$svgWrap.selectAll('.node-textbox');\n    if( $inputNode.data().length === 0 ) {\n      return isEmpty;\n    }\n    isEmpty = $inputNode.node().value.trim() === '';\n    return isEmpty;\n  }\n  appendTempNode( selectedNode, direction ) {\n\n    if( selectedNode._isEdit ) {\n      if( !this.isNodeNameEmpty() ) {\n        this.editEndNodeName();\n      }\n      return;\n    }\n    else if( selectedNode._isUserInput && direction === APPEND_DIRECTION.RIGHT ) {\n      return;\n    }\n\n    let parentNode = selectedNode.parent;\n    if( parentNode === null && direction === APPEND_DIRECTION.BOTTOM ) {\n      //ルート階層の下にノードは追加できないようにする\n      return;\n    }\n\n    // ノード追加を行うための一時ノードを生成してツリーに加える\n    let tempNodeData = this.createNodeData({\n      id: this.createNodeId(),\n      name: '',\n      children: null,\n      _isTemp: true\n    });\n\n    switch( direction ) {\n      case APPEND_DIRECTION.RIGHT:\n        this.insertChild( selectedNode, tempNodeData );\n        break;\n      case APPEND_DIRECTION.BOTTOM:\n        this.insertChild( parentNode, tempNodeData, selectedNode._childIndex + 1 );\n        break;\n    }\n\n    this.updateNode({\n      type: NODE_METHOD.APPEND_NODE_TEMP\n    });\n  }\n  updateToggleChildren() {\n    let _this = this;\n    let circleRadius = 8;\n\n    this.$nodes.each(function(d) {\n      let $node = d3.select(this);\n      let isParent = _this.hasChildren(d);\n      let hasToggle = $node.select('.node-toggle').node() !== null;\n\n      if( isParent && !hasToggle ) {\n        let $toggle = $node.append('g')\n          .attr('class', 'node-toggle')\n          .attr('transform', `translate(${_this.columnWidth - circleRadius * 2}, 0)`)\n          .on('click', (d) => {\n            _this.toggleChildren(d);\n          });\n\n        let $circles = $toggle.append('circle')\n          .attr('r', circleRadius);\n\n        let $texts = $toggle.append('text')\n          .attr('class', 'node-toggle-label')\n          .attr('width', circleRadius * 2)\n          .attr('hegith', circleRadius * 2)\n          .attr('text-anchor', 'middle')\n          .attr('dy', circleRadius / 2)\n          .text( d._isToggleOpen === false ? '+' : '–' );\n      }\n      else if( isParent && hasToggle ) {\n        $node.select('.node-toggle-label')\n          .text( d._isToggleOpen === false ? '+' : '–' );\n      }\n      else if( !isParent && hasToggle ) {\n        $node.select('.node-toggle').remove();\n      }\n    });\n  }\n  updateLineToChild() {\n    let _this = this;\n\n    this.$svgWrap.selectAll('.node-branch-line').remove();\n    this.$svgWrap.selectAll('.node--other').each(function(d) {\n      let $node = d3.select(this);\n      let isParent = _this.hasChildren(d);\n      let hasLine = $node.select('.node-branch-line').node() !== null;\n\n      // if( isParent && !hasLine && !d._isEllpsis ) {\n      //   $node.append('line')\n      //     .attr('class', 'node-branch-line')\n      //     .attr('stroke', 'black')\n      //     .attr('stroke-width', 1)\n      //     .attr('stroke-dasharray', '1 4')\n      //     .attr('x1', d._nameWidth + MARGIN.NODE_NAME.LEFT + 10)\n      //     .attr('y1', 0)\n      //     .attr('x2', _this.columnWidth - 10)\n      //     .attr('y2', 0);\n      // }\n    });\n  }\n  toggleChildren( parentData ) {\n    this.updateNode({\n      type: NODE_METHOD.TOGGLE_CHILDREN,\n      data: {\n        node: parentData\n      }\n    });\n  }\n}\n\nclass Util {\n  measureTextSize(str, $container) {\n    let $text = $container.append('text')\n      .attr('class', 'temp-measure-text')\n      .html(str);\n    let bbox = $text.node().getBBox();\n    $text.remove();\n    return bbox;\n  }\n  copySelection( $target, $to ) {\n    let node = $target.node();\n    let {nodeName, attributes, children} = node;\n    let $copy = $to.append(nodeName);\n\n    Object.keys(attributes).forEach((key) => {\n      $copy.attr(attributes[key].name, attributes[key].value);\n    });\n    $copy.html($target.html());\n\n    return $copy;\n  }\n}\n\n(function() {\n  new DirectoryTree('#tree', '.tree-wrap').init();\n}());\n\n\n// WEBPACK FOOTER //\n// ./tree-ui.js"],"sourceRoot":""}